package vmcontract

import (
	"errors"

	"github.com/qlcchain/go-qlc/common"
	"github.com/qlcchain/go-qlc/common/event"
	"github.com/qlcchain/go-qlc/common/statedb"
	"github.com/qlcchain/go-qlc/common/types"
	"github.com/qlcchain/go-qlc/vm/abi"
	"github.com/qlcchain/go-qlc/vm/vmstore"
)

type Contract interface {
	// Contract meta describe
	GetDescribe() Describe
	// Target receiver address
	GetTargetReceiver(ctx *vmstore.VMContext, block *types.StateBlock) (types.Address, error)

	GetFee(ctx *vmstore.VMContext, block *types.StateBlock) (types.Balance, error)
	// check status, update state
	DoReceive(ctx *vmstore.VMContext, block *types.StateBlock, input *types.StateBlock) ([]*ContractBlock, error)
	// refund data at receive error
	GetRefundData() []byte

	// DoPending generate pending info from send block
	DoPending(block *types.StateBlock) (*types.PendingKey, *types.PendingInfo, error)
	// ProcessSend verify or update StateBlock.Data
	DoSend(ctx *vmstore.VMContext, block *types.StateBlock) error

	// ProcessSend verify or update StateBlock.Data
	ProcessSend(ctx *vmstore.VMContext, block *types.StateBlock) (*types.PendingKey, *types.PendingInfo, error)
	DoGap(ctx *vmstore.VMContext, block *types.StateBlock) (common.ContractGapType, interface{}, error)

	DoSendOnPov(ctx *vmstore.VMContext, csdb *statedb.PovContractStateDB, povHeight uint64, block *types.StateBlock) error
	DoReceiveOnPov(ctx *vmstore.VMContext, csdb *statedb.PovContractStateDB, povHeight uint64, block *types.StateBlock, input *types.StateBlock) error

	// block trigger event
	EventNotify(eb event.EventBus, ctx *vmstore.VMContext, block *types.StateBlock) error
}

const (
	SpecVerInvalid = iota
	SpecVer1       = 1
	SpecVer2       = 2
)

type Describe struct {
	SpecVer   int
	Signature bool
	Pending   bool
	PovState  bool
	Work      bool
}

func (d Describe) GetVersion() int {
	return d.SpecVer
}
func (d Describe) WithSignature() bool {
	return d.Signature
}
func (d Describe) WithPending() bool {
	return d.Pending
}
func (d Describe) WithPovState() bool {
	return d.PovState
}
func (d Describe) WithWork() bool {
	return d.Work
}

//ContractBlock generated by contract
type ContractBlock struct {
	VMContext *vmstore.VMContext
	Block     *types.StateBlock
	ToAddress types.Address
	BlockType types.BlockType
	Amount    types.Balance
	Token     types.Hash
	Data      []byte
}

type qlcChainContract struct {
	m       map[string]Contract
	abi     abi.ABIContract
	abiJson string
}

func NewChainContract(m map[string]Contract, abi abi.ABIContract, abiJson string) *qlcChainContract {
	return &qlcChainContract{
		m:       m,
		abi:     abi,
		abiJson: abiJson,
	}
}

var qlcAllChainContracts = make(map[types.Address]*qlcChainContract)

func RegisterContracts(addr types.Address, contract *qlcChainContract) {
	qlcAllChainContracts[addr] = contract
}

func GetChainContract(addr types.Address, methodSelector []byte) (Contract, bool, error) {
	if p, ok := qlcAllChainContracts[addr]; ok {
		if method, err := p.abi.MethodById(methodSelector); err == nil {
			c, ok := p.m[method.Name]
			return c, ok, nil
		} else {
			return nil, ok, errors.New("abi: method not found")
		}
	}
	return nil, false, nil
}

func GetChainContractName(addr types.Address, methodSelector []byte) (string, bool, error) {
	if p, ok := qlcAllChainContracts[addr]; ok {
		if method, err := p.abi.MethodById(methodSelector); err == nil {
			_, ok := p.m[method.Name]
			return method.Name, ok, nil
		} else {
			return "", ok, errors.New("abi: method not found")
		}
	}

	return "", false, nil
}

func IsChainContract(addr types.Address) bool {
	if _, ok := qlcAllChainContracts[addr]; ok {
		return true
	}
	return false
}

func GetAbiByContractAddress(addr types.Address) (string, error) {
	if contract, ok := qlcAllChainContracts[addr]; ok {
		return contract.abiJson, nil
	}
	return "", errors.New("contract not found")
}
