package merkle

import (
	"math"

	"github.com/qlcchain/go-qlc/common/types"
)

// nextPowerOfTwo returns the next highest power of two from a given number if
// it is not already a power of two.  This is a helper function used during the
// calculation of a merkle tree.
func nextPowerOfTwo(n int) int {
	// Return the number if it's already a power of 2.
	if n&(n-1) == 0 {
		return n
	}

	// Figure out and return the next power of two.
	exponent := uint(math.Log2(float64(n))) + 1
	return 1 << exponent // 2^exponent
}

// HashMerkleBranches takes two hashes, treated as the left and right tree
// nodes, and returns the hash of their concatenation.  This is a helper
// function used to aid in the generation of a merkle tree.
func HashMerkleBranches(left *types.Hash, right *types.Hash) *types.Hash {
	// Concatenate the left and right nodes.
	var hash [types.HashSize * 2]byte
	copy(hash[:types.HashSize], left[:])
	copy(hash[types.HashSize:], right[:])

	newHash := types.Sha256D_HashData(hash[:])
	return &newHash
}

// BuildMerkleTreeStore creates a merkle tree from a slice of transactions,
// stores it using a linear array, and returns a slice of the backing array.  A
// linear array was chosen as opposed to an actual tree structure since it uses
// about half as much memory.  The following describes a merkle tree and how it
// is stored in a linear array.
//
// A merkle tree is a tree in which every non-leaf node is the hash of its
// children nodes.  A diagram depicting how this works for bitcoin transactions
// where h(x) is a hash256 follows:
//
//	         root = h1234 = h(h12 + h34)
//	        /                           \
//	  h12 = h(h1 + h2)            h34 = h(h3 + h4)
//	   /            \              /            \
//	h1 = h(tx1)  h2 = h(tx2)    h3 = h(tx3)  h4 = h(tx4)
//
// The above stored as a linear array is as follows:
//
// 	[h1 h2 h3 h4 h12 h34 root]
//
// As the above shows, the merkle root is always the last element in the array.
//
// The number of inputs is not always a power of two which results in a
// balanced tree structure as above.  In that case, parent nodes with no
// children are also zero and parent nodes with only a single left node
// are calculated by concatenating the left node with itself before hashing.
// Since this function uses nodes that are pointers to the hashes, empty nodes
// will be nil.
func BuildMerkleTreeStore(txHashs []*types.Hash) []*types.Hash {
	if len(txHashs) <= 0 {
		return []*types.Hash{&types.ZeroHash}
	}

	// Calculate how many entries are required to hold the binary merkle
	// tree as a linear array and create an array of that size.
	nextPoT := nextPowerOfTwo(len(txHashs))
	arraySize := nextPoT*2 - 1
	merkles := make([]*types.Hash, arraySize)

	// Create the base transaction hashes and populate the array with them.
	for i, tx := range txHashs {
		merkles[i] = tx
	}

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	offset := nextPoT
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil too.
		case merkles[i] == nil:
			merkles[offset] = nil

		// When there is no right child, the parent is generated by
		// hashing the concatenation of the left child with itself.
		case merkles[i+1] == nil:
			newHash := HashMerkleBranches(merkles[i], merkles[i])
			merkles[offset] = newHash

		// The normal case sets the parent node to the double sha256
		// of the concatenation of the left and right children.
		default:
			newHash := HashMerkleBranches(merkles[i], merkles[i+1])
			merkles[offset] = newHash
		}
		offset++
	}

	return merkles
}

// CalcMerkleTreeRootHash calculate the merkle tree root hash for a slice of transactions
func CalcMerkleTreeRootHash(txHashs []*types.Hash) types.Hash {
	if len(txHashs) <= 0 {
		return types.ZeroHash
	}

	merkles := BuildMerkleTreeStore(txHashs)
	if merkles == nil || len(merkles) <= 0 {
		return types.ZeroHash
	}

	calculatedMerkleRoot := merkles[len(merkles)-1]
	return *calculatedMerkleRoot
}

// BuildCoinbaseMerkleBranch calculate the merkel tree branch for a slice of transactions without coinbase tx
func BuildCoinbaseMerkleBranch(txHashes []*types.Hash) []*types.Hash {
	retBranches := make([]*types.Hash, 0)

	if len(txHashes) <= 0 {
		return retBranches
	}

	merkles := make([]*types.Hash, len(txHashes))
	copy(merkles, txHashes)

	for len(merkles) > 1 {
		// put first element
		retBranches = append(retBranches, merkles[0])

		if len(merkles)%2 == 0 {
			// if even, push_back the end one, size should be an odd number.
			// because we ignore the coinbase tx when make merkle branch.
			merkles = append(merkles, merkles[len(merkles)-1])
		}

		// ignore the first one than merge two
		mklLen := (len(merkles) - 1) / 2
		for i := 0; i < mklLen; i++ {
			// Hash = Double SHA256
			merkles[i] = HashMerkleBranches(merkles[i*2+1], merkles[i*2+2])
		}
		merkles = merkles[0:mklLen]
	}
	if len(merkles) != 1 {
		return retBranches
	}
	retBranches = append(retBranches, merkles[0]) // put the last one
	return retBranches
}

func CalcCoinbaseMerkleRoot(coinbaseHash *types.Hash, merkleBranch []*types.Hash) types.Hash {
	hashMerkleRoot := coinbaseHash
	for _, branchHash := range merkleBranch {
		hashMerkleRoot = HashMerkleBranches(hashMerkleRoot, branchHash)
	}
	return *hashMerkleRoot
}

func CalcMerkleRootByIndex(hash types.Hash, merkleBranch []*types.Hash, index int) types.Hash {
	if index == -1 {
		return types.ZeroHash
	}
	var sha [64]byte
	for _, it := range merkleBranch {
		if (index & 1) == 1 {
			copy(sha[:32], it[:])
			copy(sha[32:], hash[:])
			hash = types.Sha256D_HashData(sha[:])
		} else {
			copy(sha[:32], hash[:])
			copy(sha[32:], it[:])
			hash = types.Sha256D_HashData(sha[:])
		}
		index >>= 1
	}
	return hash
}

func CalcAuxPowExpectedIndex(nonce uint32, chainID, h int) int {
	rand := nonce
	rand = rand*1103515245 + 12345
	rand += uint32(chainID)
	rand = rand*1103515245 + 12345

	return int(rand % (1 << uint32(h)))
}
