// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import common "github.com/qlcchain/go-qlc/common"
import ed25519 "github.com/qlcchain/go-qlc/crypto/ed25519"
import event "github.com/qlcchain/go-qlc/common/event"
import ledger "github.com/qlcchain/go-qlc/ledger"
import mock "github.com/stretchr/testify/mock"
import storage "github.com/qlcchain/go-qlc/common/storage"
import types "github.com/qlcchain/go-qlc/common/types"

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

// Action provides a mock function with given fields: at, t
func (_m *Store) Action(at storage.ActionType, t int) (interface{}, error) {
	ret := _m.Called(at, t)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(storage.ActionType, int) interface{}); ok {
		r0 = rf(at, t)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(storage.ActionType, int) error); ok {
		r1 = rf(at, t)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddAccountMeta provides a mock function with given fields: value, c
func (_m *Store) AddAccountMeta(value *types.AccountMeta, c storage.Cache) error {
	ret := _m.Called(value, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.AccountMeta, storage.Cache) error); ok {
		r0 = rf(value, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddAccountMetaCache provides a mock function with given fields: value, batch
func (_m *Store) AddAccountMetaCache(value *types.AccountMeta, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.AccountMeta, ...storage.Batch) error); ok {
		r0 = rf(value, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddAccountMetaHistory provides a mock function with given fields: tm, block, c
func (_m *Store) AddAccountMetaHistory(tm *types.TokenMeta, block *types.StateBlock, c storage.Cache) error {
	ret := _m.Called(tm, block, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.TokenMeta, *types.StateBlock, storage.Cache) error); ok {
		r0 = rf(tm, block, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddBlockCache provides a mock function with given fields: blk, batch
func (_m *Store) AddBlockCache(blk *types.StateBlock, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, blk)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.StateBlock, ...storage.Batch) error); ok {
		r0 = rf(blk, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddBlockPrivatePayload provides a mock function with given fields: hash, payload
func (_m *Store) AddBlockPrivatePayload(hash types.Hash, payload []byte) error {
	ret := _m.Called(hash, payload)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, []byte) error); ok {
		r0 = rf(hash, payload)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddFrontier provides a mock function with given fields: frontier, c
func (_m *Store) AddFrontier(frontier *types.Frontier, c storage.Cache) error {
	ret := _m.Called(frontier, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.Frontier, storage.Cache) error); ok {
		r0 = rf(frontier, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddGapDoDSettleStateBlock provides a mock function with given fields: key, block, sync
func (_m *Store) AddGapDoDSettleStateBlock(key types.Hash, block *types.StateBlock, sync types.SynchronizedKind) error {
	ret := _m.Called(key, block, sync)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, *types.StateBlock, types.SynchronizedKind) error); ok {
		r0 = rf(key, block, sync)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddGapPovBlock provides a mock function with given fields: height, block, sync
func (_m *Store) AddGapPovBlock(height uint64, block *types.StateBlock, sync types.SynchronizedKind) error {
	ret := _m.Called(height, block, sync)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, *types.StateBlock, types.SynchronizedKind) error); ok {
		r0 = rf(height, block, sync)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddGapPublishBlock provides a mock function with given fields: key, blk, sync
func (_m *Store) AddGapPublishBlock(key types.Hash, blk *types.StateBlock, sync types.SynchronizedKind) error {
	ret := _m.Called(key, blk, sync)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, *types.StateBlock, types.SynchronizedKind) error); ok {
		r0 = rf(key, blk, sync)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddOrUpdateAccountMetaCache provides a mock function with given fields: value, batch
func (_m *Store) AddOrUpdateAccountMetaCache(value *types.AccountMeta, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.AccountMeta, ...storage.Batch) error); ok {
		r0 = rf(value, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddOrUpdatePeerInfo provides a mock function with given fields: value
func (_m *Store) AddOrUpdatePeerInfo(value *types.PeerInfo) error {
	ret := _m.Called(value)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.PeerInfo) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddOrUpdateVmLogs provides a mock function with given fields: value, c
func (_m *Store) AddOrUpdateVmLogs(value *types.VmLogs, c storage.Cache) error {
	ret := _m.Called(value, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.VmLogs, storage.Cache) error); ok {
		r0 = rf(value, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPeerInfo provides a mock function with given fields: info
func (_m *Store) AddPeerInfo(info *types.PeerInfo) error {
	ret := _m.Called(info)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.PeerInfo) error); ok {
		r0 = rf(info)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPending provides a mock function with given fields: key, value, c
func (_m *Store) AddPending(key *types.PendingKey, value *types.PendingInfo, c storage.Cache) error {
	ret := _m.Called(key, value, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.PendingKey, *types.PendingInfo, storage.Cache) error); ok {
		r0 = rf(key, value, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPovBestHash provides a mock function with given fields: height, hash, batch
func (_m *Store) AddPovBestHash(height uint64, hash types.Hash, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, height, hash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, types.Hash, ...storage.Batch) error); ok {
		r0 = rf(height, hash, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPovBlock provides a mock function with given fields: blk, td, batch
func (_m *Store) AddPovBlock(blk *types.PovBlock, td *types.PovTD, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, blk, td)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.PovBlock, *types.PovTD, ...storage.Batch) error); ok {
		r0 = rf(blk, td, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPovBody provides a mock function with given fields: height, hash, body
func (_m *Store) AddPovBody(height uint64, hash types.Hash, body *types.PovBody) error {
	ret := _m.Called(height, hash, body)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, types.Hash, *types.PovBody) error); ok {
		r0 = rf(height, hash, body)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPovDiffStat provides a mock function with given fields: dayStat
func (_m *Store) AddPovDiffStat(dayStat *types.PovDiffDayStat) error {
	ret := _m.Called(dayStat)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.PovDiffDayStat) error); ok {
		r0 = rf(dayStat)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPovHeader provides a mock function with given fields: header
func (_m *Store) AddPovHeader(header *types.PovHeader) error {
	ret := _m.Called(header)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.PovHeader) error); ok {
		r0 = rf(header)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPovHeight provides a mock function with given fields: hash, height
func (_m *Store) AddPovHeight(hash types.Hash, height uint64) error {
	ret := _m.Called(hash, height)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, uint64) error); ok {
		r0 = rf(hash, height)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPovMinerStat provides a mock function with given fields: dayStat
func (_m *Store) AddPovMinerStat(dayStat *types.PovMinerDayStat) error {
	ret := _m.Called(dayStat)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.PovMinerDayStat) error); ok {
		r0 = rf(dayStat)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPovTD provides a mock function with given fields: hash, height, td
func (_m *Store) AddPovTD(hash types.Hash, height uint64, td *types.PovTD) error {
	ret := _m.Called(hash, height, td)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, uint64, *types.PovTD) error); ok {
		r0 = rf(hash, height, td)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPovTxLookup provides a mock function with given fields: txHash, txLookup, batch
func (_m *Store) AddPovTxLookup(txHash types.Hash, txLookup *types.PovTxLookup, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, txHash, txLookup)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, *types.PovTxLookup, ...storage.Batch) error); ok {
		r0 = rf(txHash, txLookup, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddPovTxLookupInBatch provides a mock function with given fields: txHash, txLookup, batch
func (_m *Store) AddPovTxLookupInBatch(txHash types.Hash, txLookup *types.PovTxLookup, batch storage.Batch) error {
	ret := _m.Called(txHash, txLookup, batch)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, *types.PovTxLookup, storage.Batch) error); ok {
		r0 = rf(txHash, txLookup, batch)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddRepresentation provides a mock function with given fields: address, diff, c
func (_m *Store) AddRepresentation(address types.Address, diff *types.Benefit, c storage.Cache) error {
	ret := _m.Called(address, diff, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Address, *types.Benefit, storage.Cache) error); ok {
		r0 = rf(address, diff, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddSmartContractBlock provides a mock function with given fields: value
func (_m *Store) AddSmartContractBlock(value *types.SmartContractBlock) error {
	ret := _m.Called(value)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.SmartContractBlock) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddStateBlock provides a mock function with given fields: block
func (_m *Store) AddStateBlock(block *types.StateBlock) error {
	ret := _m.Called(block)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.StateBlock) error); ok {
		r0 = rf(block)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddTokenMetaConfirmed provides a mock function with given fields: address, meta, c
func (_m *Store) AddTokenMetaConfirmed(address types.Address, meta *types.TokenMeta, c storage.Cache) error {
	ret := _m.Called(address, meta, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Address, *types.TokenMeta, storage.Cache) error); ok {
		r0 = rf(address, meta, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddUncheckedBlock provides a mock function with given fields: key, value, kind, sync
func (_m *Store) AddUncheckedBlock(key types.Hash, value *types.StateBlock, kind types.UncheckedKind, sync types.SynchronizedKind) error {
	ret := _m.Called(key, value, kind, sync)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, *types.StateBlock, types.UncheckedKind, types.SynchronizedKind) error); ok {
		r0 = rf(key, value, kind, sync)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddUncheckedSyncBlock provides a mock function with given fields: previous, blk
func (_m *Store) AddUncheckedSyncBlock(previous types.Hash, blk *types.StateBlock) error {
	ret := _m.Called(previous, blk)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, *types.StateBlock) error); ok {
		r0 = rf(previous, blk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddUnconfirmedSyncBlock provides a mock function with given fields: hash, blk
func (_m *Store) AddUnconfirmedSyncBlock(hash types.Hash, blk *types.StateBlock) error {
	ret := _m.Called(hash, blk)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, *types.StateBlock) error); ok {
		r0 = rf(hash, blk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddVoteHistory provides a mock function with given fields: hash, address
func (_m *Store) AddVoteHistory(hash types.Hash, address types.Address) error {
	ret := _m.Called(hash, address)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, types.Address) error); ok {
		r0 = rf(hash, address)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BatchGetPovHeadersByHeightAsc provides a mock function with given fields: height, count
func (_m *Store) BatchGetPovHeadersByHeightAsc(height uint64, count uint64) ([]*types.PovHeader, error) {
	ret := _m.Called(height, count)

	var r0 []*types.PovHeader
	if rf, ok := ret.Get(0).(func(uint64, uint64) []*types.PovHeader); ok {
		r0 = rf(height, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.PovHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64, uint64) error); ok {
		r1 = rf(height, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetPovHeadersByHeightDesc provides a mock function with given fields: height, count
func (_m *Store) BatchGetPovHeadersByHeightDesc(height uint64, count uint64) ([]*types.PovHeader, error) {
	ret := _m.Called(height, count)

	var r0 []*types.PovHeader
	if rf, ok := ret.Get(0).(func(uint64, uint64) []*types.PovHeader); ok {
		r0 = rf(height, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.PovHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64, uint64) error); ok {
		r1 = rf(height, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlockConfirmed provides a mock function with given fields: blk
func (_m *Store) BlockConfirmed(blk *types.StateBlock) {
	_m.Called(blk)
}

// Blocks provides a mock function with given fields: limit, offset
func (_m *Store) Blocks(limit int, offset int) ([]types.Hash, error) {
	ret := _m.Called(limit, offset)

	var r0 []types.Hash
	if rf, ok := ret.Get(0).(func(int, int) []types.Hash); ok {
		r0 = rf(limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int, int) error); ok {
		r1 = rf(limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlocksByAccount provides a mock function with given fields: address, limit, offset
func (_m *Store) BlocksByAccount(address types.Address, limit int, offset int) ([]types.Hash, error) {
	ret := _m.Called(address, limit, offset)

	var r0 []types.Hash
	if rf, ok := ret.Get(0).(func(types.Address, int, int) []types.Hash); ok {
		r0 = rf(address, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, int, int) error); ok {
		r1 = rf(address, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlocksCount provides a mock function with given fields:
func (_m *Store) BlocksCount() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlocksCountByType provides a mock function with given fields:
func (_m *Store) BlocksCountByType() (map[string]uint64, error) {
	ret := _m.Called()

	var r0 map[string]uint64
	if rf, ok := ret.Get(0).(func() map[string]uint64); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]uint64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cache provides a mock function with given fields:
func (_m *Store) Cache() *ledger.MemoryCache {
	ret := _m.Called()

	var r0 *ledger.MemoryCache
	if rf, ok := ret.Get(0).(func() *ledger.MemoryCache); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ledger.MemoryCache)
		}
	}

	return r0
}

// CalculateAmount provides a mock function with given fields: block
func (_m *Store) CalculateAmount(block *types.StateBlock) (types.Balance, error) {
	ret := _m.Called(block)

	var r0 types.Balance
	if rf, ok := ret.Get(0).(func(*types.StateBlock) types.Balance); ok {
		r0 = rf(block)
	} else {
		r0 = ret.Get(0).(types.Balance)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.StateBlock) error); ok {
		r1 = rf(block)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CleanAllVoteHistory provides a mock function with given fields:
func (_m *Store) CleanAllVoteHistory() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CleanBlockVoteHistory provides a mock function with given fields: hash
func (_m *Store) CleanBlockVoteHistory(hash types.Hash) error {
	ret := _m.Called(hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash) error); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CleanSyncCache provides a mock function with given fields:
func (_m *Store) CleanSyncCache() {
	_m.Called()
}

// Close provides a mock function with given fields:
func (_m *Store) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ContractAddress provides a mock function with given fields: b
func (_m *Store) ContractAddress(b *types.StateBlock) (*types.Address, error) {
	ret := _m.Called(b)

	var r0 *types.Address
	if rf, ok := ret.Get(0).(func(*types.StateBlock) *types.Address); ok {
		r0 = rf(b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.StateBlock) error); ok {
		r1 = rf(b)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountAccountMetas provides a mock function with given fields:
func (_m *Store) CountAccountMetas() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountBlocksCache provides a mock function with given fields:
func (_m *Store) CountBlocksCache() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountFrontiers provides a mock function with given fields:
func (_m *Store) CountFrontiers() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountPeersInfo provides a mock function with given fields:
func (_m *Store) CountPeersInfo() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountPovAccountTxs provides a mock function with given fields:
func (_m *Store) CountPovAccountTxs() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountPovBestHashs provides a mock function with given fields:
func (_m *Store) CountPovBestHashs() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountPovBlocks provides a mock function with given fields:
func (_m *Store) CountPovBlocks() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountPovTxs provides a mock function with given fields:
func (_m *Store) CountPovTxs() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountRepresentations provides a mock function with given fields:
func (_m *Store) CountRepresentations() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountSmartContractBlocks provides a mock function with given fields:
func (_m *Store) CountSmartContractBlocks() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountStateBlocks provides a mock function with given fields:
func (_m *Store) CountStateBlocks() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountUncheckedBlocks provides a mock function with given fields:
func (_m *Store) CountUncheckedBlocks() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountUncheckedBlocksStore provides a mock function with given fields:
func (_m *Store) CountUncheckedBlocksStore() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountUncheckedSyncBlocks provides a mock function with given fields:
func (_m *Store) CountUncheckedSyncBlocks() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountUnconfirmedSyncBlocks provides a mock function with given fields:
func (_m *Store) CountUnconfirmedSyncBlocks() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountVmLogs provides a mock function with given fields:
func (_m *Store) CountVmLogs() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DBStore provides a mock function with given fields:
func (_m *Store) DBStore() storage.Store {
	ret := _m.Called()

	var r0 storage.Store
	if rf, ok := ret.Get(0).(func() storage.Store); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.Store)
		}
	}

	return r0
}

// DebugAllPovInfos provides a mock function with given fields:
func (_m *Store) DebugAllPovInfos() {
	_m.Called()
}

// DeleteAccountMeta provides a mock function with given fields: key, c
func (_m *Store) DeleteAccountMeta(key types.Address, c storage.Cache) error {
	ret := _m.Called(key, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Address, storage.Cache) error); ok {
		r0 = rf(key, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteAccountMetaCache provides a mock function with given fields: key, batch
func (_m *Store) DeleteAccountMetaCache(key types.Address, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Address, ...storage.Batch) error); ok {
		r0 = rf(key, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteBlockCache provides a mock function with given fields: hash, batch
func (_m *Store) DeleteBlockCache(hash types.Hash, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, hash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, ...storage.Batch) error); ok {
		r0 = rf(hash, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteBlockPrivatePayload provides a mock function with given fields: hash
func (_m *Store) DeleteBlockPrivatePayload(hash types.Hash) error {
	ret := _m.Called(hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash) error); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteFrontier provides a mock function with given fields: key, c
func (_m *Store) DeleteFrontier(key types.Hash, c storage.Cache) error {
	ret := _m.Called(key, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, storage.Cache) error); ok {
		r0 = rf(key, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGapDoDSettleStateBlock provides a mock function with given fields: key, blkHash
func (_m *Store) DeleteGapDoDSettleStateBlock(key types.Hash, blkHash types.Hash) error {
	ret := _m.Called(key, blkHash)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, types.Hash) error); ok {
		r0 = rf(key, blkHash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGapPovBlock provides a mock function with given fields: height, hash
func (_m *Store) DeleteGapPovBlock(height uint64, hash types.Hash) error {
	ret := _m.Called(height, hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, types.Hash) error); ok {
		r0 = rf(height, hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGapPublishBlock provides a mock function with given fields: key, blkHash
func (_m *Store) DeleteGapPublishBlock(key types.Hash, blkHash types.Hash) error {
	ret := _m.Called(key, blkHash)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, types.Hash) error); ok {
		r0 = rf(key, blkHash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePending provides a mock function with given fields: key, c
func (_m *Store) DeletePending(key *types.PendingKey, c storage.Cache) error {
	ret := _m.Called(key, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.PendingKey, storage.Cache) error); ok {
		r0 = rf(key, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePovBestHash provides a mock function with given fields: height, batch
func (_m *Store) DeletePovBestHash(height uint64, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, height)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, ...storage.Batch) error); ok {
		r0 = rf(height, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePovBlock provides a mock function with given fields: blk
func (_m *Store) DeletePovBlock(blk *types.PovBlock) error {
	ret := _m.Called(blk)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.PovBlock) error); ok {
		r0 = rf(blk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePovBody provides a mock function with given fields: height, hash
func (_m *Store) DeletePovBody(height uint64, hash types.Hash) error {
	ret := _m.Called(height, hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, types.Hash) error); ok {
		r0 = rf(height, hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePovDiffStat provides a mock function with given fields: dayIndex
func (_m *Store) DeletePovDiffStat(dayIndex uint32) error {
	ret := _m.Called(dayIndex)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint32) error); ok {
		r0 = rf(dayIndex)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePovHeader provides a mock function with given fields: height, hash
func (_m *Store) DeletePovHeader(height uint64, hash types.Hash) error {
	ret := _m.Called(height, hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, types.Hash) error); ok {
		r0 = rf(height, hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePovHeight provides a mock function with given fields: hash
func (_m *Store) DeletePovHeight(hash types.Hash) error {
	ret := _m.Called(hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash) error); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePovMinerStat provides a mock function with given fields: dayIndex
func (_m *Store) DeletePovMinerStat(dayIndex uint32) error {
	ret := _m.Called(dayIndex)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint32) error); ok {
		r0 = rf(dayIndex)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePovTD provides a mock function with given fields: hash, height
func (_m *Store) DeletePovTD(hash types.Hash, height uint64) error {
	ret := _m.Called(hash, height)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, uint64) error); ok {
		r0 = rf(hash, height)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePovTxLookup provides a mock function with given fields: txHash, batch
func (_m *Store) DeletePovTxLookup(txHash types.Hash, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, txHash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, ...storage.Batch) error); ok {
		r0 = rf(txHash, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePovTxLookupInBatch provides a mock function with given fields: txHash, batch
func (_m *Store) DeletePovTxLookupInBatch(txHash types.Hash, batch storage.Batch) error {
	ret := _m.Called(txHash, batch)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, storage.Batch) error); ok {
		r0 = rf(txHash, batch)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteStateBlock provides a mock function with given fields: key, c
func (_m *Store) DeleteStateBlock(key types.Hash, c storage.Cache) error {
	ret := _m.Called(key, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, storage.Cache) error); ok {
		r0 = rf(key, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTokenMetaCache provides a mock function with given fields: address, tokenType, batch
func (_m *Store) DeleteTokenMetaCache(address types.Address, tokenType types.Hash, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address, tokenType)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Address, types.Hash, ...storage.Batch) error); ok {
		r0 = rf(address, tokenType, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTokenMetaConfirmed provides a mock function with given fields: address, tokenType, c
func (_m *Store) DeleteTokenMetaConfirmed(address types.Address, tokenType types.Hash, c storage.Cache) error {
	ret := _m.Called(address, tokenType, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Address, types.Hash, storage.Cache) error); ok {
		r0 = rf(address, tokenType, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUncheckedBlock provides a mock function with given fields: key, kind
func (_m *Store) DeleteUncheckedBlock(key types.Hash, kind types.UncheckedKind) error {
	ret := _m.Called(key, kind)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, types.UncheckedKind) error); ok {
		r0 = rf(key, kind)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUncheckedSyncBlock provides a mock function with given fields: hash
func (_m *Store) DeleteUncheckedSyncBlock(hash types.Hash) error {
	ret := _m.Called(hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash) error); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUnconfirmedSyncBlock provides a mock function with given fields: hash
func (_m *Store) DeleteUnconfirmedSyncBlock(hash types.Hash) error {
	ret := _m.Called(hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash) error); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteVmLogs provides a mock function with given fields: key, c
func (_m *Store) DeleteVmLogs(key types.Hash, c storage.Cache) error {
	ret := _m.Called(key, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, storage.Cache) error); ok {
		r0 = rf(key, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DropAllPovBlocks provides a mock function with given fields:
func (_m *Store) DropAllPovBlocks() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EmptyRelation provides a mock function with given fields:
func (_m *Store) EmptyRelation() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EventBus provides a mock function with given fields:
func (_m *Store) EventBus() event.EventBus {
	ret := _m.Called()

	var r0 event.EventBus
	if rf, ok := ret.Get(0).(func() event.EventBus); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.EventBus)
		}
	}

	return r0
}

// Flush provides a mock function with given fields:
func (_m *Store) Flush() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FlushU provides a mock function with given fields:
func (_m *Store) FlushU() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenerateChangeBlock provides a mock function with given fields: account, representative, prk
func (_m *Store) GenerateChangeBlock(account types.Address, representative types.Address, prk ed25519.PrivateKey) (*types.StateBlock, error) {
	ret := _m.Called(account, representative, prk)

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func(types.Address, types.Address, ed25519.PrivateKey) *types.StateBlock); ok {
		r0 = rf(account, representative, prk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, types.Address, ed25519.PrivateKey) error); ok {
		r1 = rf(account, representative, prk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateOnlineBlock provides a mock function with given fields: account, prk, povHeight
func (_m *Store) GenerateOnlineBlock(account types.Address, prk ed25519.PrivateKey, povHeight uint64) (*types.StateBlock, error) {
	ret := _m.Called(account, prk, povHeight)

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func(types.Address, ed25519.PrivateKey, uint64) *types.StateBlock); ok {
		r0 = rf(account, prk, povHeight)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, ed25519.PrivateKey, uint64) error); ok {
		r1 = rf(account, prk, povHeight)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateReceiveBlock provides a mock function with given fields: sendBlock, prk
func (_m *Store) GenerateReceiveBlock(sendBlock *types.StateBlock, prk ed25519.PrivateKey) (*types.StateBlock, error) {
	ret := _m.Called(sendBlock, prk)

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func(*types.StateBlock, ed25519.PrivateKey) *types.StateBlock); ok {
		r0 = rf(sendBlock, prk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.StateBlock, ed25519.PrivateKey) error); ok {
		r1 = rf(sendBlock, prk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateSendBlock provides a mock function with given fields: block, amount, prk
func (_m *Store) GenerateSendBlock(block *types.StateBlock, amount types.Balance, prk ed25519.PrivateKey) (*types.StateBlock, error) {
	ret := _m.Called(block, amount, prk)

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func(*types.StateBlock, types.Balance, ed25519.PrivateKey) *types.StateBlock); ok {
		r0 = rf(block, amount, prk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.StateBlock, types.Balance, ed25519.PrivateKey) error); ok {
		r1 = rf(block, amount, prk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: k, c
func (_m *Store) Get(k []byte, c ...storage.Cache) ([]byte, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, k)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte, ...storage.Cache) []byte); ok {
		r0 = rf(k, c...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, ...storage.Cache) error); ok {
		r1 = rf(k, c...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountMeta provides a mock function with given fields: address, c
func (_m *Store) GetAccountMeta(address types.Address, c ...storage.Cache) (*types.AccountMeta, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.AccountMeta
	if rf, ok := ret.Get(0).(func(types.Address, ...storage.Cache) *types.AccountMeta); ok {
		r0 = rf(address, c...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AccountMeta)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, ...storage.Cache) error); ok {
		r1 = rf(address, c...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountMetaByPovHeight provides a mock function with given fields: address, height
func (_m *Store) GetAccountMetaByPovHeight(address types.Address, height uint64) (*types.AccountMeta, error) {
	ret := _m.Called(address, height)

	var r0 *types.AccountMeta
	if rf, ok := ret.Get(0).(func(types.Address, uint64) *types.AccountMeta); ok {
		r0 = rf(address, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AccountMeta)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, uint64) error); ok {
		r1 = rf(address, height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountMetaCaches provides a mock function with given fields: fn
func (_m *Store) GetAccountMetaCaches(fn func(*types.AccountMeta) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.AccountMeta) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAccountMetaConfirmed provides a mock function with given fields: address, c
func (_m *Store) GetAccountMetaConfirmed(address types.Address, c ...storage.Cache) (*types.AccountMeta, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.AccountMeta
	if rf, ok := ret.Get(0).(func(types.Address, ...storage.Cache) *types.AccountMeta); ok {
		r0 = rf(address, c...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AccountMeta)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, ...storage.Cache) error); ok {
		r1 = rf(address, c...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountMetas provides a mock function with given fields: fn
func (_m *Store) GetAccountMetas(fn func(*types.AccountMeta) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.AccountMeta) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAccountMeteCache provides a mock function with given fields: key, batch
func (_m *Store) GetAccountMeteCache(key types.Address, batch ...storage.Batch) (*types.AccountMeta, error) {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.AccountMeta
	if rf, ok := ret.Get(0).(func(types.Address, ...storage.Batch) *types.AccountMeta); ok {
		r0 = rf(key, batch...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AccountMeta)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, ...storage.Batch) error); ok {
		r1 = rf(key, batch...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllPovBestBlocks provides a mock function with given fields: fn
func (_m *Store) GetAllPovBestBlocks(fn func(*types.PovBlock) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.PovBlock) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAllPovBestHashes provides a mock function with given fields: fn
func (_m *Store) GetAllPovBestHashes(fn func(uint64, types.Hash) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(uint64, types.Hash) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAllPovBestHeaders provides a mock function with given fields: fn
func (_m *Store) GetAllPovBestHeaders(fn func(*types.PovHeader) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.PovHeader) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAllPovBlocks provides a mock function with given fields: fn
func (_m *Store) GetAllPovBlocks(fn func(*types.PovBlock) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.PovBlock) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAllPovDiffStats provides a mock function with given fields: fn
func (_m *Store) GetAllPovDiffStats(fn func(*types.PovDiffDayStat) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.PovDiffDayStat) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAllPovHeaders provides a mock function with given fields: fn
func (_m *Store) GetAllPovHeaders(fn func(*types.PovHeader) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.PovHeader) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAllPovMinerStats provides a mock function with given fields: fn
func (_m *Store) GetAllPovMinerStats(fn func(*types.PovMinerDayStat) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.PovMinerDayStat) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBlockCache provides a mock function with given fields: key
func (_m *Store) GetBlockCache(key types.Hash) (*types.StateBlock, error) {
	ret := _m.Called(key)

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func(types.Hash) *types.StateBlock); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockCaches provides a mock function with given fields: fn
func (_m *Store) GetBlockCaches(fn func(*types.StateBlock) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.StateBlock) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBlockChild provides a mock function with given fields: hash, c
func (_m *Store) GetBlockChild(hash types.Hash, c ...storage.Cache) (types.Hash, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, hash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 types.Hash
	if rf, ok := ret.Get(0).(func(types.Hash, ...storage.Cache) types.Hash); ok {
		r0 = rf(hash, c...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash, ...storage.Cache) error); ok {
		r1 = rf(hash, c...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockLink provides a mock function with given fields: key, c
func (_m *Store) GetBlockLink(key types.Hash, c ...storage.Cache) (types.Hash, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 types.Hash
	if rf, ok := ret.Get(0).(func(types.Hash, ...storage.Cache) types.Hash); ok {
		r0 = rf(key, c...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash, ...storage.Cache) error); ok {
		r1 = rf(key, c...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockPrivatePayload provides a mock function with given fields: hash
func (_m *Store) GetBlockPrivatePayload(hash types.Hash) ([]byte, error) {
	ret := _m.Called(hash)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(types.Hash) []byte); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCacheStat provides a mock function with given fields:
func (_m *Store) GetCacheStat() []*ledger.CacheStat {
	ret := _m.Called()

	var r0 []*ledger.CacheStat
	if rf, ok := ret.Get(0).(func() []*ledger.CacheStat); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ledger.CacheStat)
		}
	}

	return r0
}

// GetCacheStatue provides a mock function with given fields:
func (_m *Store) GetCacheStatue() map[string]string {
	ret := _m.Called()

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func() map[string]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	return r0
}

// GetFrontier provides a mock function with given fields: hash, cache
func (_m *Store) GetFrontier(hash types.Hash, cache ...storage.Cache) (*types.Frontier, error) {
	_va := make([]interface{}, len(cache))
	for _i := range cache {
		_va[_i] = cache[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, hash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Frontier
	if rf, ok := ret.Get(0).(func(types.Hash, ...storage.Cache) *types.Frontier); ok {
		r0 = rf(hash, cache...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Frontier)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash, ...storage.Cache) error); ok {
		r1 = rf(hash, cache...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFrontiers provides a mock function with given fields:
func (_m *Store) GetFrontiers() ([]*types.Frontier, error) {
	ret := _m.Called()

	var r0 []*types.Frontier
	if rf, ok := ret.Get(0).(func() []*types.Frontier); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Frontier)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGapDoDSettleStateBlock provides a mock function with given fields: key, visit
func (_m *Store) GetGapDoDSettleStateBlock(key types.Hash, visit types.GapDoDSettleStateBlockWalkFunc) error {
	ret := _m.Called(key, visit)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, types.GapDoDSettleStateBlockWalkFunc) error); ok {
		r0 = rf(key, visit)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetGapPublishBlocks provides a mock function with given fields: key, visit
func (_m *Store) GetGapPublishBlock(key types.Hash, visit types.GapPublishBlockWalkFunc) error {
	ret := _m.Called(key, visit)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Hash, types.GapPublishBlockWalkFunc) error); ok {
		r0 = rf(key, visit)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetLastGapPovHeight provides a mock function with given fields:
func (_m *Store) GetLastGapPovHeight() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// GetLatestPovBestHash provides a mock function with given fields:
func (_m *Store) GetLatestPovBestHash() (types.Hash, error) {
	ret := _m.Called()

	var r0 types.Hash
	if rf, ok := ret.Get(0).(func() types.Hash); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestPovBlock provides a mock function with given fields:
func (_m *Store) GetLatestPovBlock() (*types.PovBlock, error) {
	ret := _m.Called()

	var r0 *types.PovBlock
	if rf, ok := ret.Get(0).(func() *types.PovBlock); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestPovDiffStat provides a mock function with given fields:
func (_m *Store) GetLatestPovDiffStat() (*types.PovDiffDayStat, error) {
	ret := _m.Called()

	var r0 *types.PovDiffDayStat
	if rf, ok := ret.Get(0).(func() *types.PovDiffDayStat); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovDiffDayStat)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestPovHeader provides a mock function with given fields:
func (_m *Store) GetLatestPovHeader() (*types.PovHeader, error) {
	ret := _m.Called()

	var r0 *types.PovHeader
	if rf, ok := ret.Get(0).(func() *types.PovHeader); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestPovMinerStat provides a mock function with given fields: batch
func (_m *Store) GetLatestPovMinerStat(batch ...storage.Batch) (*types.PovMinerDayStat, error) {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.PovMinerDayStat
	if rf, ok := ret.Get(0).(func(...storage.Batch) *types.PovMinerDayStat); ok {
		r0 = rf(batch...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovMinerDayStat)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(...storage.Batch) error); ok {
		r1 = rf(batch...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetObject provides a mock function with given fields: k, c
func (_m *Store) GetObject(k []byte, c ...storage.Cache) (interface{}, []byte, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, k)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func([]byte, ...storage.Cache) interface{}); ok {
		r0 = rf(k, c...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 []byte
	if rf, ok := ret.Get(1).(func([]byte, ...storage.Cache) []byte); ok {
		r1 = rf(k, c...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func([]byte, ...storage.Cache) error); ok {
		r2 = rf(k, c...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetOnlineRepresentations provides a mock function with given fields:
func (_m *Store) GetOnlineRepresentations() ([]types.Address, error) {
	ret := _m.Called()

	var r0 []types.Address
	if rf, ok := ret.Get(0).(func() []types.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPeerInfo provides a mock function with given fields: peerID
func (_m *Store) GetPeerInfo(peerID string) (*types.PeerInfo, error) {
	ret := _m.Called(peerID)

	var r0 *types.PeerInfo
	if rf, ok := ret.Get(0).(func(string) *types.PeerInfo); ok {
		r0 = rf(peerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PeerInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(peerID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPeersInfo provides a mock function with given fields: fn
func (_m *Store) GetPeersInfo(fn func(*types.PeerInfo) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.PeerInfo) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetPending provides a mock function with given fields: pendingKey
func (_m *Store) GetPending(pendingKey *types.PendingKey) (*types.PendingInfo, error) {
	ret := _m.Called(pendingKey)

	var r0 *types.PendingInfo
	if rf, ok := ret.Get(0).(func(*types.PendingKey) *types.PendingInfo); ok {
		r0 = rf(pendingKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PendingInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.PendingKey) error); ok {
		r1 = rf(pendingKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPendings provides a mock function with given fields: fn
func (_m *Store) GetPendings(fn func(*types.PendingKey, *types.PendingInfo) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.PendingKey, *types.PendingInfo) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetPendingsByAddress provides a mock function with given fields: address, fn
func (_m *Store) GetPendingsByAddress(address types.Address, fn func(*types.PendingKey, *types.PendingInfo) error) error {
	ret := _m.Called(address, fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Address, func(*types.PendingKey, *types.PendingInfo) error) error); ok {
		r0 = rf(address, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetPendingsByToken provides a mock function with given fields: account, token, fn
func (_m *Store) GetPendingsByToken(account types.Address, token types.Hash, fn func(*types.PendingKey, *types.PendingInfo) error) error {
	ret := _m.Called(account, token, fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Address, types.Hash, func(*types.PendingKey, *types.PendingInfo) error) error); ok {
		r0 = rf(account, token, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetPovBestHash provides a mock function with given fields: height, batch
func (_m *Store) GetPovBestHash(height uint64, batch ...storage.Batch) (types.Hash, error) {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, height)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 types.Hash
	if rf, ok := ret.Get(0).(func(uint64, ...storage.Batch) types.Hash); ok {
		r0 = rf(height, batch...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64, ...storage.Batch) error); ok {
		r1 = rf(height, batch...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovBlockByHash provides a mock function with given fields: hash
func (_m *Store) GetPovBlockByHash(hash types.Hash) (*types.PovBlock, error) {
	ret := _m.Called(hash)

	var r0 *types.PovBlock
	if rf, ok := ret.Get(0).(func(types.Hash) *types.PovBlock); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovBlockByHeight provides a mock function with given fields: height
func (_m *Store) GetPovBlockByHeight(height uint64) (*types.PovBlock, error) {
	ret := _m.Called(height)

	var r0 *types.PovBlock
	if rf, ok := ret.Get(0).(func(uint64) *types.PovBlock); ok {
		r0 = rf(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovBlockByHeightAndHash provides a mock function with given fields: height, hash
func (_m *Store) GetPovBlockByHeightAndHash(height uint64, hash types.Hash) (*types.PovBlock, error) {
	ret := _m.Called(height, hash)

	var r0 *types.PovBlock
	if rf, ok := ret.Get(0).(func(uint64, types.Hash) *types.PovBlock); ok {
		r0 = rf(height, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64, types.Hash) error); ok {
		r1 = rf(height, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovBody provides a mock function with given fields: height, hash
func (_m *Store) GetPovBody(height uint64, hash types.Hash) (*types.PovBody, error) {
	ret := _m.Called(height, hash)

	var r0 *types.PovBody
	if rf, ok := ret.Get(0).(func(uint64, types.Hash) *types.PovBody); ok {
		r0 = rf(height, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovBody)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64, types.Hash) error); ok {
		r1 = rf(height, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovDiffStat provides a mock function with given fields: dayIndex
func (_m *Store) GetPovDiffStat(dayIndex uint32) (*types.PovDiffDayStat, error) {
	ret := _m.Called(dayIndex)

	var r0 *types.PovDiffDayStat
	if rf, ok := ret.Get(0).(func(uint32) *types.PovDiffDayStat); ok {
		r0 = rf(dayIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovDiffDayStat)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint32) error); ok {
		r1 = rf(dayIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovHeader provides a mock function with given fields: height, hash
func (_m *Store) GetPovHeader(height uint64, hash types.Hash) (*types.PovHeader, error) {
	ret := _m.Called(height, hash)

	var r0 *types.PovHeader
	if rf, ok := ret.Get(0).(func(uint64, types.Hash) *types.PovHeader); ok {
		r0 = rf(height, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64, types.Hash) error); ok {
		r1 = rf(height, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovHeaderByHash provides a mock function with given fields: hash
func (_m *Store) GetPovHeaderByHash(hash types.Hash) (*types.PovHeader, error) {
	ret := _m.Called(hash)

	var r0 *types.PovHeader
	if rf, ok := ret.Get(0).(func(types.Hash) *types.PovHeader); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovHeaderByHeight provides a mock function with given fields: height
func (_m *Store) GetPovHeaderByHeight(height uint64) (*types.PovHeader, error) {
	ret := _m.Called(height)

	var r0 *types.PovHeader
	if rf, ok := ret.Get(0).(func(uint64) *types.PovHeader); ok {
		r0 = rf(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovHeight provides a mock function with given fields: hash
func (_m *Store) GetPovHeight(hash types.Hash) (uint64, error) {
	ret := _m.Called(hash)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(types.Hash) uint64); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovLatestHeight provides a mock function with given fields:
func (_m *Store) GetPovLatestHeight() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovMinerStat provides a mock function with given fields: dayIndex, batch
func (_m *Store) GetPovMinerStat(dayIndex uint32, batch ...storage.Batch) (*types.PovMinerDayStat, error) {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, dayIndex)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.PovMinerDayStat
	if rf, ok := ret.Get(0).(func(uint32, ...storage.Batch) *types.PovMinerDayStat); ok {
		r0 = rf(dayIndex, batch...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovMinerDayStat)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint32, ...storage.Batch) error); ok {
		r1 = rf(dayIndex, batch...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovTD provides a mock function with given fields: hash, height, batch
func (_m *Store) GetPovTD(hash types.Hash, height uint64, batch ...storage.Batch) (*types.PovTD, error) {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, hash, height)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.PovTD
	if rf, ok := ret.Get(0).(func(types.Hash, uint64, ...storage.Batch) *types.PovTD); ok {
		r0 = rf(hash, height, batch...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovTD)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash, uint64, ...storage.Batch) error); ok {
		r1 = rf(hash, height, batch...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovTxLookup provides a mock function with given fields: txHash
func (_m *Store) GetPovTxLookup(txHash types.Hash) (*types.PovTxLookup, error) {
	ret := _m.Called(txHash)

	var r0 *types.PovTxLookup
	if rf, ok := ret.Get(0).(func(types.Hash) *types.PovTxLookup); ok {
		r0 = rf(txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PovTxLookup)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPovTxlScanCursor provides a mock function with given fields:
func (_m *Store) GetPovTxlScanCursor() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRandomStateBlock provides a mock function with given fields:
func (_m *Store) GetRandomStateBlock() (*types.StateBlock, error) {
	ret := _m.Called()

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func() *types.StateBlock); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRelation provides a mock function with given fields: dest, query
func (_m *Store) GetRelation(dest interface{}, query string) error {
	ret := _m.Called(dest, query)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, string) error); ok {
		r0 = rf(dest, query)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetRepresentation provides a mock function with given fields: key, c
func (_m *Store) GetRepresentation(key types.Address, c ...storage.Cache) (*types.Benefit, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Benefit
	if rf, ok := ret.Get(0).(func(types.Address, ...storage.Cache) *types.Benefit); ok {
		r0 = rf(key, c...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Benefit)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, ...storage.Cache) error); ok {
		r1 = rf(key, c...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepresentations provides a mock function with given fields: fn
func (_m *Store) GetRepresentations(fn func(types.Address, *types.Benefit) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(types.Address, *types.Benefit) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetSmartContractBlock provides a mock function with given fields: key
func (_m *Store) GetSmartContractBlock(key types.Hash) (*types.SmartContractBlock, error) {
	ret := _m.Called(key)

	var r0 *types.SmartContractBlock
	if rf, ok := ret.Get(0).(func(types.Hash) *types.SmartContractBlock); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SmartContractBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSmartContractBlocks provides a mock function with given fields: fn
func (_m *Store) GetSmartContractBlocks(fn func(*types.SmartContractBlock) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.SmartContractBlock) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetStateBlock provides a mock function with given fields: hash, c
func (_m *Store) GetStateBlock(hash types.Hash, c ...storage.Cache) (*types.StateBlock, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, hash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func(types.Hash, ...storage.Cache) *types.StateBlock); ok {
		r0 = rf(hash, c...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash, ...storage.Cache) error); ok {
		r1 = rf(hash, c...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStateBlockConfirmed provides a mock function with given fields: hash, c
func (_m *Store) GetStateBlockConfirmed(hash types.Hash, c ...storage.Cache) (*types.StateBlock, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, hash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func(types.Hash, ...storage.Cache) *types.StateBlock); ok {
		r0 = rf(hash, c...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash, ...storage.Cache) error); ok {
		r1 = rf(hash, c...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStateBlocksConfirmed provides a mock function with given fields: fn
func (_m *Store) GetStateBlocksConfirmed(fn func(*types.StateBlock) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*types.StateBlock) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetTokenById provides a mock function with given fields: tokenId
func (_m *Store) GetTokenById(tokenId types.Hash) (*types.TokenInfo, error) {
	ret := _m.Called(tokenId)

	var r0 *types.TokenInfo
	if rf, ok := ret.Get(0).(func(types.Hash) *types.TokenInfo); ok {
		r0 = rf(tokenId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TokenInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(tokenId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenByName provides a mock function with given fields: tokenName
func (_m *Store) GetTokenByName(tokenName string) (*types.TokenInfo, error) {
	ret := _m.Called(tokenName)

	var r0 *types.TokenInfo
	if rf, ok := ret.Get(0).(func(string) *types.TokenInfo); ok {
		r0 = rf(tokenName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TokenInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(tokenName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenMeta provides a mock function with given fields: address, tokenType
func (_m *Store) GetTokenMeta(address types.Address, tokenType types.Hash) (*types.TokenMeta, error) {
	ret := _m.Called(address, tokenType)

	var r0 *types.TokenMeta
	if rf, ok := ret.Get(0).(func(types.Address, types.Hash) *types.TokenMeta); ok {
		r0 = rf(address, tokenType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TokenMeta)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, types.Hash) error); ok {
		r1 = rf(address, tokenType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenMetaByBlockHash provides a mock function with given fields: hash
func (_m *Store) GetTokenMetaByBlockHash(hash types.Hash) (*types.TokenMeta, error) {
	ret := _m.Called(hash)

	var r0 *types.TokenMeta
	if rf, ok := ret.Get(0).(func(types.Hash) *types.TokenMeta); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TokenMeta)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenMetaByPovHeight provides a mock function with given fields: address, token, height
func (_m *Store) GetTokenMetaByPovHeight(address types.Address, token types.Hash, height uint64) (*types.TokenMeta, error) {
	ret := _m.Called(address, token, height)

	var r0 *types.TokenMeta
	if rf, ok := ret.Get(0).(func(types.Address, types.Hash, uint64) *types.TokenMeta); ok {
		r0 = rf(address, token, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TokenMeta)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, types.Hash, uint64) error); ok {
		r1 = rf(address, token, height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenMetaConfirmed provides a mock function with given fields: address, tokenType
func (_m *Store) GetTokenMetaConfirmed(address types.Address, tokenType types.Hash) (*types.TokenMeta, error) {
	ret := _m.Called(address, tokenType)

	var r0 *types.TokenMeta
	if rf, ok := ret.Get(0).(func(types.Address, types.Hash) *types.TokenMeta); ok {
		r0 = rf(address, tokenType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TokenMeta)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, types.Hash) error); ok {
		r1 = rf(address, tokenType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUCacheStat provides a mock function with given fields:
func (_m *Store) GetUCacheStat() []*ledger.CacheStat {
	ret := _m.Called()

	var r0 []*ledger.CacheStat
	if rf, ok := ret.Get(0).(func() []*ledger.CacheStat); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ledger.CacheStat)
		}
	}

	return r0
}

// GetUCacheStatue provides a mock function with given fields:
func (_m *Store) GetUCacheStatue() map[string]string {
	ret := _m.Called()

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func() map[string]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	return r0
}

// GetUncheckedBlock provides a mock function with given fields: parentHash, kind
func (_m *Store) GetUncheckedBlock(parentHash types.Hash, kind types.UncheckedKind) (*types.StateBlock, types.SynchronizedKind, error) {
	ret := _m.Called(parentHash, kind)

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func(types.Hash, types.UncheckedKind) *types.StateBlock); ok {
		r0 = rf(parentHash, kind)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 types.SynchronizedKind
	if rf, ok := ret.Get(1).(func(types.Hash, types.UncheckedKind) types.SynchronizedKind); ok {
		r1 = rf(parentHash, kind)
	} else {
		r1 = ret.Get(1).(types.SynchronizedKind)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(types.Hash, types.UncheckedKind) error); ok {
		r2 = rf(parentHash, kind)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetUncheckedBlocks provides a mock function with given fields: visit
func (_m *Store) GetUncheckedBlocks(visit types.UncheckedBlockWalkFunc) error {
	ret := _m.Called(visit)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.UncheckedBlockWalkFunc) error); ok {
		r0 = rf(visit)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetUncheckedSyncBlock provides a mock function with given fields: hash
func (_m *Store) GetUncheckedSyncBlock(hash types.Hash) (*types.StateBlock, error) {
	ret := _m.Called(hash)

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func(types.Hash) *types.StateBlock); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUnconfirmedSyncBlock provides a mock function with given fields: hash
func (_m *Store) GetUnconfirmedSyncBlock(hash types.Hash) (*types.StateBlock, error) {
	ret := _m.Called(hash)

	var r0 *types.StateBlock
	if rf, ok := ret.Get(0).(func(types.Hash) *types.StateBlock); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVerifiedData provides a mock function with given fields:
func (_m *Store) GetVerifiedData() map[types.Hash]int {
	ret := _m.Called()

	var r0 map[types.Hash]int
	if rf, ok := ret.Get(0).(func() map[types.Hash]int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[types.Hash]int)
		}
	}

	return r0
}

// GetVmLogs provides a mock function with given fields: key, c
func (_m *Store) GetVmLogs(key types.Hash, c ...storage.Cache) (*types.VmLogs, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.VmLogs
	if rf, ok := ret.Get(0).(func(types.Hash, ...storage.Cache) *types.VmLogs); ok {
		r0 = rf(key, c...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.VmLogs)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash, ...storage.Cache) error); ok {
		r1 = rf(key, c...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasAccountMetaCache provides a mock function with given fields: key
func (_m *Store) HasAccountMetaCache(key types.Address) (bool, error) {
	ret := _m.Called(key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Address) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasAccountMetaConfirmed provides a mock function with given fields: address
func (_m *Store) HasAccountMetaConfirmed(address types.Address) (bool, error) {
	ret := _m.Called(address)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Address) bool); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasBlockCache provides a mock function with given fields: key
func (_m *Store) HasBlockCache(key types.Hash) (bool, error) {
	ret := _m.Called(key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasPovBlock provides a mock function with given fields: height, hash, batch
func (_m *Store) HasPovBlock(height uint64, hash types.Hash, batch ...storage.Batch) bool {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, height, hash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint64, types.Hash, ...storage.Batch) bool); ok {
		r0 = rf(height, hash, batch...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// HasPovBody provides a mock function with given fields: height, hash, batch
func (_m *Store) HasPovBody(height uint64, hash types.Hash, batch ...storage.Batch) bool {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, height, hash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint64, types.Hash, ...storage.Batch) bool); ok {
		r0 = rf(height, hash, batch...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// HasPovHeader provides a mock function with given fields: height, hash, batch
func (_m *Store) HasPovHeader(height uint64, hash types.Hash, batch ...storage.Batch) bool {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, height, hash)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint64, types.Hash, ...storage.Batch) bool); ok {
		r0 = rf(height, hash, batch...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// HasPovHeight provides a mock function with given fields: hash
func (_m *Store) HasPovHeight(hash types.Hash) bool {
	ret := _m.Called(hash)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash) bool); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// HasPovMinerStat provides a mock function with given fields: dayIndex
func (_m *Store) HasPovMinerStat(dayIndex uint32) bool {
	ret := _m.Called(dayIndex)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint32) bool); ok {
		r0 = rf(dayIndex)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// HasPovTxLookup provides a mock function with given fields: txHash
func (_m *Store) HasPovTxLookup(txHash types.Hash) bool {
	ret := _m.Called(txHash)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash) bool); ok {
		r0 = rf(txHash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// HasSmartContractBlock provides a mock function with given fields: key
func (_m *Store) HasSmartContractBlock(key types.Hash) (bool, error) {
	ret := _m.Called(key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasStateBlock provides a mock function with given fields: hash
func (_m *Store) HasStateBlock(hash types.Hash) (bool, error) {
	ret := _m.Called(hash)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash) bool); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasStateBlockConfirmed provides a mock function with given fields: hash
func (_m *Store) HasStateBlockConfirmed(hash types.Hash) (bool, error) {
	ret := _m.Called(hash)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash) bool); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasTokenMeta provides a mock function with given fields: address, tokenType
func (_m *Store) HasTokenMeta(address types.Address, tokenType types.Hash) (bool, error) {
	ret := _m.Called(address, tokenType)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Address, types.Hash) bool); ok {
		r0 = rf(address, tokenType)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, types.Hash) error); ok {
		r1 = rf(address, tokenType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasUncheckedBlock provides a mock function with given fields: hash, kind
func (_m *Store) HasUncheckedBlock(hash types.Hash, kind types.UncheckedKind) (bool, error) {
	ret := _m.Called(hash, kind)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash, types.UncheckedKind) bool); ok {
		r0 = rf(hash, kind)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash, types.UncheckedKind) error); ok {
		r1 = rf(hash, kind)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasUncheckedSyncBlock provides a mock function with given fields: hash
func (_m *Store) HasUncheckedSyncBlock(hash types.Hash) (bool, error) {
	ret := _m.Called(hash)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash) bool); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasUnconfirmedSyncBlock provides a mock function with given fields: hash
func (_m *Store) HasUnconfirmedSyncBlock(hash types.Hash) (bool, error) {
	ret := _m.Called(hash)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash) bool); ok {
		r0 = rf(hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasVmLogs provides a mock function with given fields: key, c
func (_m *Store) HasVmLogs(key types.Hash, c ...storage.Cache) (bool, error) {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash, ...storage.Cache) bool); ok {
		r0 = rf(key, c...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Hash, ...storage.Cache) error); ok {
		r1 = rf(key, c...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasVoteHistory provides a mock function with given fields: hash, address
func (_m *Store) HasVoteHistory(hash types.Hash, address types.Address) bool {
	ret := _m.Called(hash, address)

	var r0 bool
	if rf, ok := ret.Get(0).(func(types.Hash, types.Address) bool); ok {
		r0 = rf(hash, address)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Iterator provides a mock function with given fields: _a0, _a1, _a2
func (_m *Store) Iterator(_a0 []byte, _a1 []byte, _a2 func([]byte, []byte) error) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, func([]byte, []byte) error) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IteratorObject provides a mock function with given fields: prefix, end, fn
func (_m *Store) IteratorObject(prefix []byte, end []byte, fn func([]byte, interface{}) error) error {
	ret := _m.Called(prefix, end, fn)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, func([]byte, interface{}) error) error); ok {
		r0 = rf(prefix, end, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListTokens provides a mock function with given fields:
func (_m *Store) ListTokens() ([]*types.TokenInfo, error) {
	ret := _m.Called()

	var r0 []*types.TokenInfo
	if rf, ok := ret.Get(0).(func() []*types.TokenInfo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.TokenInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewVMIterator provides a mock function with given fields: address
func (_m *Store) NewVMIterator(address *types.Address) *ledger.Iterator {
	ret := _m.Called(address)

	var r0 *ledger.Iterator
	if rf, ok := ret.Get(0).(func(*types.Address) *ledger.Iterator); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ledger.Iterator)
		}
	}

	return r0
}

// PendingAmount provides a mock function with given fields: address, token
func (_m *Store) PendingAmount(address types.Address, token types.Hash) (types.Balance, error) {
	ret := _m.Called(address, token)

	var r0 types.Balance
	if rf, ok := ret.Get(0).(func(types.Address, types.Hash) types.Balance); ok {
		r0 = rf(address, token)
	} else {
		r0 = ret.Get(0).(types.Balance)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Address, types.Hash) error); ok {
		r1 = rf(address, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PovHeightAddGap provides a mock function with given fields: height
func (_m *Store) PovHeightAddGap(height uint64) error {
	ret := _m.Called(height)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(height)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PovHeightDeleteGap provides a mock function with given fields: height
func (_m *Store) PovHeightDeleteGap(height uint64) error {
	ret := _m.Called(height)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(height)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PovHeightHasGap provides a mock function with given fields: height
func (_m *Store) PovHeightHasGap(height uint64) (bool, error) {
	ret := _m.Called(height)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint64) bool); ok {
		r0 = rf(height)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveStorage provides a mock function with given fields: key, val, c
func (_m *Store) RemoveStorage(key []byte, val []byte, c storage.Cache) error {
	ret := _m.Called(key, val, c)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, storage.Cache) error); ok {
		r0 = rf(key, val, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveStorage provides a mock function with given fields: val, c
func (_m *Store) SaveStorage(val map[string]interface{}, c ...storage.Cache) error {
	_va := make([]interface{}, len(c))
	for _i := range c {
		_va[_i] = c[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, val)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, ...storage.Cache) error); ok {
		r0 = rf(val, c...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveStorageByConvert provides a mock function with given fields: key, val, c
func (_m *Store) SaveStorageByConvert(key []byte, val []byte, c storage.Cache) error {
	ret := _m.Called(key, val, c)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, storage.Cache) error); ok {
		r0 = rf(key, val, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SearchVmLogs provides a mock function with given fields: fn
func (_m *Store) SearchVmLogs(fn func(types.Hash, *types.VmLogs) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(types.Hash, *types.VmLogs) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SelectRelation provides a mock function with given fields: dest, query
func (_m *Store) SelectRelation(dest interface{}, query string) error {
	ret := _m.Called(dest, query)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, string) error); ok {
		r0 = rf(dest, query)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetLastGapPovHeight provides a mock function with given fields: height
func (_m *Store) SetLastGapPovHeight(height uint64) error {
	ret := _m.Called(height)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(height)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetOnlineRepresentations provides a mock function with given fields: addresses
func (_m *Store) SetOnlineRepresentations(addresses []*types.Address) error {
	ret := _m.Called(addresses)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*types.Address) error); ok {
		r0 = rf(addresses)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetPovLatestHeight provides a mock function with given fields: height, batch
func (_m *Store) SetPovLatestHeight(height uint64, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, height)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, ...storage.Batch) error); ok {
		r0 = rf(height, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetPovTxlScanCursor provides a mock function with given fields: height, batch
func (_m *Store) SetPovTxlScanCursor(height uint64, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, height)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, ...storage.Batch) error); ok {
		r0 = rf(height, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetStorage provides a mock function with given fields: val
func (_m *Store) SetStorage(val map[string]interface{}) error {
	ret := _m.Called(val)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) error); ok {
		r0 = rf(val)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubRepresentation provides a mock function with given fields: address, diff, c
func (_m *Store) SubRepresentation(address types.Address, diff *types.Benefit, c storage.Cache) error {
	ret := _m.Called(address, diff, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Address, *types.Benefit, storage.Cache) error); ok {
		r0 = rf(address, diff, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UCache provides a mock function with given fields:
func (_m *Store) UCache() *ledger.MemoryCache {
	ret := _m.Called()

	var r0 *ledger.MemoryCache
	if rf, ok := ret.Get(0).(func() *ledger.MemoryCache); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ledger.MemoryCache)
		}
	}

	return r0
}

// UpdateAccountMeta provides a mock function with given fields: value, c
func (_m *Store) UpdateAccountMeta(value *types.AccountMeta, c storage.Cache) error {
	ret := _m.Called(value, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.AccountMeta, storage.Cache) error); ok {
		r0 = rf(value, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateAccountMetaHistory provides a mock function with given fields: tm, block, c
func (_m *Store) UpdateAccountMetaHistory(tm *types.TokenMeta, block *types.StateBlock, c storage.Cache) error {
	ret := _m.Called(tm, block, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.TokenMeta, *types.StateBlock, storage.Cache) error); ok {
		r0 = rf(tm, block, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateAccountMeteCache provides a mock function with given fields: value, batch
func (_m *Store) UpdateAccountMeteCache(value *types.AccountMeta, batch ...storage.Batch) error {
	_va := make([]interface{}, len(batch))
	for _i := range batch {
		_va[_i] = batch[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.AccountMeta, ...storage.Batch) error); ok {
		r0 = rf(value, batch...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdatePeerInfo provides a mock function with given fields: value
func (_m *Store) UpdatePeerInfo(value *types.PeerInfo) error {
	ret := _m.Called(value)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.PeerInfo) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateStateBlock provides a mock function with given fields: block, c
func (_m *Store) UpdateStateBlock(block *types.StateBlock, c storage.Cache) error {
	ret := _m.Called(block, c)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.StateBlock, storage.Cache) error); ok {
		r0 = rf(block, c)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WalkGapPovBlocks provides a mock function with given fields: visit
func (_m *Store) WalkGapPovBlocks(visit types.GapPovBlockWalkFunc) error {
	ret := _m.Called(visit)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.GapPovBlockWalkFunc) error); ok {
		r0 = rf(visit)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WalkGapPovBlocksWithHeight provides a mock function with given fields: height, visit
func (_m *Store) WalkGapPovBlocksWithHeight(height uint64, visit types.GapPovBlockWalkFunc) error {
	ret := _m.Called(height, visit)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, types.GapPovBlockWalkFunc) error); ok {
		r0 = rf(height, visit)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WalkSyncCache provides a mock function with given fields: visit
func (_m *Store) WalkSyncCache(visit common.SyncCacheWalkFunc) {
	_m.Called(visit)
}

// Weight provides a mock function with given fields: account
func (_m *Store) Weight(account types.Address) types.Balance {
	ret := _m.Called(account)

	var r0 types.Balance
	if rf, ok := ret.Get(0).(func(types.Address) types.Balance); ok {
		r0 = rf(account)
	} else {
		r0 = ret.Get(0).(types.Balance)
	}

	return r0
}
