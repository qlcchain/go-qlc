// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package ledger

import (
	"reflect"
	"testing"

	"github.com/qlcchain/go-qlc/common/types"
	"github.com/qlcchain/go-qlc/mock"
)

func addContractValue(t *testing.T, l *Ledger) (*types.ContractKey, *types.ContractValue) {
	key := &types.ContractKey{
		ContractAddress: mock.Address(),
		AccountAddress:  mock.Address(),
		Hash:            types.ZeroHash,
		Suffix:          nil,
	}
	value := &types.ContractValue{
		BlockHash: mock.Hash(),
	}
	if err := l.AddOrUpdateContractValue(key, value, l.cache.GetCache()); err != nil {
		t.Fatal(err)
	}
	return key, value
}

func TestLedger_AddContractValue(t *testing.T) {
	teardownTestCase, l := setupTestCase(t)
	defer teardownTestCase(t)
	addContractValue(t, l)
}

func TestLedger_GetContractValue(t *testing.T) {
	teardownTestCase, l := setupTestCase(t)
	defer teardownTestCase(t)

	k, v := addContractValue(t, l)
	value, err := l.GetContractValue(k)
	if err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(v, value) {
		t.Fatal(err)
	}
}

func TestLedger_DeleteContractValue(t *testing.T) {
	teardownTestCase, l := setupTestCase(t)
	defer teardownTestCase(t)

	k, _ := addContractValue(t, l)
	err := l.DeleteContractValue(k, l.cache.GetCache())
	if err != nil {
		t.Fatal(err)
	}
	_, err = l.GetContractValue(k)
	if err == nil {
		t.Fatal(err)
	}
}

func TestLedger_AddOrUpdateContractValue(t *testing.T) {
	teardownTestCase, l := setupTestCase(t)
	defer teardownTestCase(t)
	addContractValue(t, l)

	k := &types.ContractKey{}
	v := &types.ContractValue{}
	err := l.AddOrUpdateContractValue(k, v)
	if err != nil {
		t.Fatal(err)
	}
}

func TestLedger_GetContractValues(t *testing.T) {
	teardownTestCase, l := setupTestCase(t)
	defer teardownTestCase(t)

	addContractValue(t, l)
	addContractValue(t, l)
	err := l.GetContractValues(func(key *types.ContractKey, value *types.ContractValue) error {
		t.Log(key)
		t.Log(value)
		return nil
	})
	if err != nil {
		t.Fatal(err)
	}
}

func TestLedger_CountContractValue(t *testing.T) {
	teardownTestCase, l := setupTestCase(t)
	defer teardownTestCase(t)

	addContractValue(t, l)
	addContractValue(t, l)
	if err := l.Flush(); err != nil {
		t.Fatal(err)
	}
	num, err := l.CountContractValues()
	if err != nil {
		t.Fatal(err)
	}
	if num != 2 {
		t.Fatal("error count")
	}
	t.Log("account,", num)
}

func TestLedger_HasContractValue(t *testing.T) {
	teardownTestCase, l := setupTestCase(t)
	defer teardownTestCase(t)

	k, _ := addContractValue(t, l)
	b, err := l.HasContractValue(k)
	if err != nil || !b {
		t.Fatal(err)
	}
}

func TestLedger_BatchUpdateContractValue(t *testing.T) {
	teardownTestCase, l := setupTestCase(t)
	defer teardownTestCase(t)

	var cache []*types.StateBlock
	ca := mock.Address()
	a := mock.Address()
	previous := types.ZeroHash
	for i := 0; i < 5; i++ {
		block := mock.StateBlockWithAddress(a)
		block.Type = types.ContractSend
		block.Link = ca.ToHash()
		//block.Previous = mock.Hash()
		cache = append(cache, block)
		h := block.GetHash()
		if err := l.UpdateContractValueByBlock(block); err != nil {
			t.Fatal(err)
		}
		if value, err := l.GetContractValue(&types.ContractKey{
			ContractAddress: ca,
			AccountAddress:  block.Address,
			Hash:            block.Token,
			Suffix:          LatestSuffix,
		}); err != nil {
			t.Fatal(err)
		} else {
			if value.BlockHash.IsZero() {
				t.Fatalf("%v", value.BlockHash)
			}
		}

		if value, err := l.GetContractValue(&types.ContractKey{
			ContractAddress: ca,
			AccountAddress:  block.Address,
			Hash:            h,
		}); err != nil {
			t.Fatal(err)
		} else {
			if value.BlockHash != previous {
				t.Fatalf("invalid hash, act:%v, exp: %v", value.BlockHash, previous)
			}
		}
		previous = h
	}

	if count, err := l.CountContractValues(); err != nil {
		t.Fatal(err)
	} else {
		if count != 6 {
			t.Fatalf("invalid count, exp: 6, act: %d", count)
		}
	}

	for i := len(cache) - 1; i >= 0; i-- {
		if err := l.DeleteContractValueByBlock(cache[i]); err != nil {
			t.Fatal(err)
		}
	}

	if count, err := l.CountContractValues(); err != nil {
		t.Fatal(err)
	} else {
		if count != 0 {
			t.Fatalf("invalid count, exp: 0, act: %d", count)
		}
	}
}

func TestLedger_IteratorContractStorage(t *testing.T) {
	teardownTestCase, l := setupTestCase(t)
	defer teardownTestCase(t)

	counter := make(map[types.Address]int, 0)
	addr := mock.Address()
	ca := mock.Address()
	token := mock.Hash()
	for i := 0; i < 4; i++ {
		var block *types.StateBlock
		if i%2 == 0 {
			block = mock.StateBlockWithAddress(addr)
		}
		block = mock.StateBlockWithoutWork()
		block.Type = types.ContractSend
		block.Link = ca.ToHash()
		block.Token = token
		if err := l.UpdateContractValueByBlock(block); err != nil {
			t.Fatal(err)
		}
		if _, ok := counter[block.Address]; ok {
			counter[block.Address]++
		} else {
			counter[block.Address] = 1
		}
	}
	if count, err := l.CountContractValues(); err != nil {
		t.Fatal(err)
	} else {
		if int(count) != len(counter)*2 {
			t.Fatalf("invalid count: exp: %d,act:%d", len(counter)*2, count)
		}
	}

	c := make(map[types.Address]int, 0)
	if err := l.IteratorContractStorage(ca[:], func(key *types.ContractKey, value *types.ContractValue) error {
		if len(key.Suffix) == 0 {
			if _, ok := c[key.AccountAddress]; ok {
				c[key.AccountAddress]++
			} else {
				c[key.AccountAddress] = 1
			}
		}
		return nil
	}); err != nil {
		t.Fatal(err)
	}

	if len(c) != len(counter) {
		t.Fatalf("invalid account counts,exp: %d, act: %d", len(counter), len(c))
	}

	for k, v := range counter {
		if v2, ok := c[k]; ok {
			if v != v2 {
				t.Fatalf("invalid records size of %s, exp: %d, act: %d", k, v, v2)
			}
		} else {
			t.Fatalf("can not find %s in db", k)
		}
	}
}
