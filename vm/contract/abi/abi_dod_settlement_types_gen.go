package abi

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *DoDBillingType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDBillingType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDBillingType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDBillingType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDBillingType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDBillingType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDBillingType) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDOrderOperation) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDOrderOperation(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDOrderOperation) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDOrderOperation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDOrderOperation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDOrderOperation(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDOrderOperation) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDPaymentType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDPaymentType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDPaymentType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDPaymentType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDPaymentType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDPaymentType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDPaymentType) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDResponseAction) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDResponseAction(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDResponseAction) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDResponseAction) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDResponseAction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDResponseAction(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDResponseAction) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDServiceClass) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDServiceClass(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDServiceClass) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDServiceClass) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDServiceClass) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDServiceClass(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDServiceClass) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleChangeConnectionParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "o":
			z.ProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "DoDSettleConnectionDynamicParam":
			err = z.DoDSettleConnectionDynamicParam.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleChangeConnectionParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "o"
	err = en.Append(0x82, 0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductId)
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	// write "DoDSettleConnectionDynamicParam"
	err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = z.DoDSettleConnectionDynamicParam.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleChangeConnectionParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "o"
	o = append(o, 0x82, 0xa1, 0x6f)
	o = msgp.AppendString(o, z.ProductId)
	// string "DoDSettleConnectionDynamicParam"
	o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	o, err = z.DoDSettleConnectionDynamicParam.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleChangeConnectionParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "o":
			z.ProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "DoDSettleConnectionDynamicParam":
			bts, err = z.DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleChangeConnectionParam) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.ProductId) + 32 + z.DoDSettleConnectionDynamicParam.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleChangeOrderParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "c":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0004) {
				z.Connections = (z.Connections)[:zb0004]
			} else {
				z.Connections = make([]*DoDSettleChangeConnectionParam, zb0004)
			}
			for za0001 := range z.Connections {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleChangeConnectionParam)
					}
					var zb0005 uint32
					zb0005, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "o":
							z.Connections[za0001].ProductId, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "ProductId")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							err = z.Connections[za0001].DoDSettleConnectionDynamicParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleChangeOrderParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "b"
	err = en.Append(0x83, 0xa1, 0x62)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Connections)))
	if err != nil {
		err = msgp.WrapError(err, "Connections")
		return
	}
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "o"
			err = en.Append(0x82, 0xa1, 0x6f)
			if err != nil {
				return
			}
			err = en.WriteString(z.Connections[za0001].ProductId)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "ProductId")
				return
			}
			// write "DoDSettleConnectionDynamicParam"
			err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionDynamicParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleChangeOrderParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "b"
	o = append(o, 0x83, 0xa1, 0x62)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Connections)))
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "o"
			o = append(o, 0x82, 0xa1, 0x6f)
			o = msgp.AppendString(o, z.Connections[za0001].ProductId)
			// string "DoDSettleConnectionDynamicParam"
			o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleChangeOrderParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "c":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0004) {
				z.Connections = (z.Connections)[:zb0004]
			} else {
				z.Connections = make([]*DoDSettleChangeConnectionParam, zb0004)
			}
			for za0001 := range z.Connections {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleChangeConnectionParam)
					}
					var zb0005 uint32
					zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "o":
							z.Connections[za0001].ProductId, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "ProductId")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleChangeOrderParam) Msgsize() (s int) {
	s = 1 + 2
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 2
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 2 + msgp.StringPrefixSize + len(z.Connections[za0001].ProductId) + 32 + z.Connections[za0001].DoDSettleConnectionDynamicParam.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionDynamicParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cn":
			z.ConnectionName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ConnectionName")
				return
			}
		case "pt":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PaymentType")
					return
				}
				z.PaymentType = DoDPaymentType(zb0002)
			}
		case "bt":
			{
				var zb0003 int
				zb0003, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BillingType")
					return
				}
				z.BillingType = DoDBillingType(zb0003)
			}
		case "cr":
			z.Currency, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "scs":
			{
				var zb0004 int
				zb0004, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ServiceClass")
					return
				}
				z.ServiceClass = DoDServiceClass(zb0004)
			}
		case "bw":
			z.Bandwidth, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bandwidth")
				return
			}
		case "bu":
			{
				var zb0005 int
				zb0005, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BillingUnit")
					return
				}
				z.BillingUnit = DodBillingUnit(zb0005)
			}
		case "p":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "st":
			z.StartTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "et":
			z.EndTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionDynamicParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 10
	// write "cn"
	err = en.Append(0x8a, 0xa2, 0x63, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.ConnectionName)
	if err != nil {
		err = msgp.WrapError(err, "ConnectionName")
		return
	}
	// write "pt"
	err = en.Append(0xa2, 0x70, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.PaymentType))
	if err != nil {
		err = msgp.WrapError(err, "PaymentType")
		return
	}
	// write "bt"
	err = en.Append(0xa2, 0x62, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.BillingType))
	if err != nil {
		err = msgp.WrapError(err, "BillingType")
		return
	}
	// write "cr"
	err = en.Append(0xa2, 0x63, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Currency)
	if err != nil {
		err = msgp.WrapError(err, "Currency")
		return
	}
	// write "scs"
	err = en.Append(0xa3, 0x73, 0x63, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.ServiceClass))
	if err != nil {
		err = msgp.WrapError(err, "ServiceClass")
		return
	}
	// write "bw"
	err = en.Append(0xa2, 0x62, 0x77)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bandwidth)
	if err != nil {
		err = msgp.WrapError(err, "Bandwidth")
		return
	}
	// write "bu"
	err = en.Append(0xa2, 0x62, 0x75)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.BillingUnit))
	if err != nil {
		err = msgp.WrapError(err, "BillingUnit")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "st"
	err = en.Append(0xa2, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "et"
	err = en.Append(0xa2, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndTime)
	if err != nil {
		err = msgp.WrapError(err, "EndTime")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionDynamicParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "cn"
	o = append(o, 0x8a, 0xa2, 0x63, 0x6e)
	o = msgp.AppendString(o, z.ConnectionName)
	// string "pt"
	o = append(o, 0xa2, 0x70, 0x74)
	o = msgp.AppendInt(o, int(z.PaymentType))
	// string "bt"
	o = append(o, 0xa2, 0x62, 0x74)
	o = msgp.AppendInt(o, int(z.BillingType))
	// string "cr"
	o = append(o, 0xa2, 0x63, 0x72)
	o = msgp.AppendString(o, z.Currency)
	// string "scs"
	o = append(o, 0xa3, 0x73, 0x63, 0x73)
	o = msgp.AppendInt(o, int(z.ServiceClass))
	// string "bw"
	o = append(o, 0xa2, 0x62, 0x77)
	o = msgp.AppendString(o, z.Bandwidth)
	// string "bu"
	o = append(o, 0xa2, 0x62, 0x75)
	o = msgp.AppendInt(o, int(z.BillingUnit))
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendFloat64(o, z.Price)
	// string "st"
	o = append(o, 0xa2, 0x73, 0x74)
	o = msgp.AppendInt64(o, z.StartTime)
	// string "et"
	o = append(o, 0xa2, 0x65, 0x74)
	o = msgp.AppendInt64(o, z.EndTime)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionDynamicParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cn":
			z.ConnectionName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ConnectionName")
				return
			}
		case "pt":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PaymentType")
					return
				}
				z.PaymentType = DoDPaymentType(zb0002)
			}
		case "bt":
			{
				var zb0003 int
				zb0003, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BillingType")
					return
				}
				z.BillingType = DoDBillingType(zb0003)
			}
		case "cr":
			z.Currency, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "scs":
			{
				var zb0004 int
				zb0004, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ServiceClass")
					return
				}
				z.ServiceClass = DoDServiceClass(zb0004)
			}
		case "bw":
			z.Bandwidth, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bandwidth")
				return
			}
		case "bu":
			{
				var zb0005 int
				zb0005, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BillingUnit")
					return
				}
				z.BillingUnit = DodBillingUnit(zb0005)
			}
		case "p":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "st":
			z.StartTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "et":
			z.EndTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionDynamicParam) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ConnectionName) + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.Currency) + 4 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.Bandwidth) + 3 + msgp.IntSize + 2 + msgp.Float64Size + 3 + msgp.Int64Size + 3 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "oi":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "r":
			z.Ready, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Ready")
				return
			}
		case "DoDSettleConnectionStaticParam":
			err = z.DoDSettleConnectionStaticParam.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
				return
			}
		case "pd":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Pending")
					return
				}
				z.Pending = nil
			} else {
				if z.Pending == nil {
					z.Pending = new(DoDSettleConnectionDynamicParam)
				}
				err = z.Pending.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Pending")
					return
				}
			}
		case "ac":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Active")
					return
				}
				z.Active = nil
			} else {
				if z.Active == nil {
					z.Active = new(DoDSettleConnectionDynamicParam)
				}
				err = z.Active.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Active")
					return
				}
			}
		case "do":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Done")
				return
			}
			if cap(z.Done) >= int(zb0002) {
				z.Done = (z.Done)[:zb0002]
			} else {
				z.Done = make([]*DoDSettleConnectionDynamicParam, zb0002)
			}
			for za0001 := range z.Done {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Done", za0001)
						return
					}
					z.Done[za0001] = nil
				} else {
					if z.Done[za0001] == nil {
						z.Done[za0001] = new(DoDSettleConnectionDynamicParam)
					}
					err = z.Done[za0001].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Done", za0001)
						return
					}
				}
			}
		case "t":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Track")
				return
			}
			if cap(z.Track) >= int(zb0003) {
				z.Track = (z.Track)[:zb0003]
			} else {
				z.Track = make([]*DoDSettleConnectionLifeTrack, zb0003)
			}
			for za0002 := range z.Track {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
					z.Track[za0002] = nil
				} else {
					if z.Track[za0002] == nil {
						z.Track[za0002] = new(DoDSettleConnectionLifeTrack)
					}
					err = z.Track[za0002].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "oi"
	err = en.Append(0x87, 0xa2, 0x6f, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Ready)
	if err != nil {
		err = msgp.WrapError(err, "Ready")
		return
	}
	// write "DoDSettleConnectionStaticParam"
	err = en.Append(0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = z.DoDSettleConnectionStaticParam.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
		return
	}
	// write "pd"
	err = en.Append(0xa2, 0x70, 0x64)
	if err != nil {
		return
	}
	if z.Pending == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Pending.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Pending")
			return
		}
	}
	// write "ac"
	err = en.Append(0xa2, 0x61, 0x63)
	if err != nil {
		return
	}
	if z.Active == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Active.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Active")
			return
		}
	}
	// write "do"
	err = en.Append(0xa2, 0x64, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Done)))
	if err != nil {
		err = msgp.WrapError(err, "Done")
		return
	}
	for za0001 := range z.Done {
		if z.Done[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Done[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Done", za0001)
				return
			}
		}
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Track)))
	if err != nil {
		err = msgp.WrapError(err, "Track")
		return
	}
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Track[za0002].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Track", za0002)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "oi"
	o = append(o, 0x87, 0xa2, 0x6f, 0x69)
	o = msgp.AppendString(o, z.OrderId)
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendBool(o, z.Ready)
	// string "DoDSettleConnectionStaticParam"
	o = append(o, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	o, err = z.DoDSettleConnectionStaticParam.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
		return
	}
	// string "pd"
	o = append(o, 0xa2, 0x70, 0x64)
	if z.Pending == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Pending.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Pending")
			return
		}
	}
	// string "ac"
	o = append(o, 0xa2, 0x61, 0x63)
	if z.Active == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Active.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Active")
			return
		}
	}
	// string "do"
	o = append(o, 0xa2, 0x64, 0x6f)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Done)))
	for za0001 := range z.Done {
		if z.Done[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Done[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Done", za0001)
				return
			}
		}
	}
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Track)))
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Track[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Track", za0002)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "oi":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "r":
			z.Ready, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Ready")
				return
			}
		case "DoDSettleConnectionStaticParam":
			bts, err = z.DoDSettleConnectionStaticParam.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
				return
			}
		case "pd":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Pending = nil
			} else {
				if z.Pending == nil {
					z.Pending = new(DoDSettleConnectionDynamicParam)
				}
				bts, err = z.Pending.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pending")
					return
				}
			}
		case "ac":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Active = nil
			} else {
				if z.Active == nil {
					z.Active = new(DoDSettleConnectionDynamicParam)
				}
				bts, err = z.Active.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Active")
					return
				}
			}
		case "do":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Done")
				return
			}
			if cap(z.Done) >= int(zb0002) {
				z.Done = (z.Done)[:zb0002]
			} else {
				z.Done = make([]*DoDSettleConnectionDynamicParam, zb0002)
			}
			for za0001 := range z.Done {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Done[za0001] = nil
				} else {
					if z.Done[za0001] == nil {
						z.Done[za0001] = new(DoDSettleConnectionDynamicParam)
					}
					bts, err = z.Done[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Done", za0001)
						return
					}
				}
			}
		case "t":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Track")
				return
			}
			if cap(z.Track) >= int(zb0003) {
				z.Track = (z.Track)[:zb0003]
			} else {
				z.Track = make([]*DoDSettleConnectionLifeTrack, zb0003)
			}
			for za0002 := range z.Track {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Track[za0002] = nil
				} else {
					if z.Track[za0002] == nil {
						z.Track[za0002] = new(DoDSettleConnectionLifeTrack)
					}
					bts, err = z.Track[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionInfo) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.OrderId) + 2 + msgp.BoolSize + 31 + z.DoDSettleConnectionStaticParam.Msgsize() + 3
	if z.Pending == nil {
		s += msgp.NilSize
	} else {
		s += z.Pending.Msgsize()
	}
	s += 3
	if z.Active == nil {
		s += msgp.NilSize
	} else {
		s += z.Active.Msgsize()
	}
	s += 3 + msgp.ArrayHeaderSize
	for za0001 := range z.Done {
		if z.Done[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Done[za0001].Msgsize()
		}
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Track[za0002].Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionLifeTrack) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Param":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Param")
					return
				}
				z.Param = nil
			} else {
				if z.Param == nil {
					z.Param = new(DoDSettleConnectionDynamicParam)
				}
				err = z.Param.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Param")
					return
				}
			}
		case "t":
			z.Time, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		case "h":
			err = dc.ReadExtension(&z.Hash)
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionLifeTrack) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "Param"
	err = en.Append(0x83, 0xa5, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	if z.Param == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Param.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Param")
			return
		}
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Time)
	if err != nil {
		err = msgp.WrapError(err, "Time")
		return
	}
	// write "h"
	err = en.Append(0xa1, 0x68)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.Hash)
	if err != nil {
		err = msgp.WrapError(err, "Hash")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionLifeTrack) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Param"
	o = append(o, 0x83, 0xa5, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if z.Param == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Param.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Param")
			return
		}
	}
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt64(o, z.Time)
	// string "h"
	o = append(o, 0xa1, 0x68)
	o, err = msgp.AppendExtension(o, &z.Hash)
	if err != nil {
		err = msgp.WrapError(err, "Hash")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionLifeTrack) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Param":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Param = nil
			} else {
				if z.Param == nil {
					z.Param = new(DoDSettleConnectionDynamicParam)
				}
				bts, err = z.Param.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Param")
					return
				}
			}
		case "t":
			z.Time, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		case "h":
			bts, err = msgp.ReadExtensionBytes(bts, &z.Hash)
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionLifeTrack) Msgsize() (s int) {
	s = 1 + 6
	if z.Param == nil {
		s += msgp.NilSize
	} else {
		s += z.Param.Msgsize()
	}
	s += 2 + msgp.Int64Size + 2 + msgp.ExtensionPrefixSize + z.Hash.Len()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DoDSettleConnectionStaticParam":
			err = z.DoDSettleConnectionStaticParam.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
				return
			}
		case "DoDSettleConnectionDynamicParam":
			err = z.DoDSettleConnectionDynamicParam.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "DoDSettleConnectionStaticParam"
	err = en.Append(0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = z.DoDSettleConnectionStaticParam.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
		return
	}
	// write "DoDSettleConnectionDynamicParam"
	err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = z.DoDSettleConnectionDynamicParam.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "DoDSettleConnectionStaticParam"
	o = append(o, 0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	o, err = z.DoDSettleConnectionStaticParam.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
		return
	}
	// string "DoDSettleConnectionDynamicParam"
	o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	o, err = z.DoDSettleConnectionDynamicParam.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DoDSettleConnectionStaticParam":
			bts, err = z.DoDSettleConnectionStaticParam.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
				return
			}
		case "DoDSettleConnectionDynamicParam":
			bts, err = z.DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionParam) Msgsize() (s int) {
	s = 1 + 31 + z.DoDSettleConnectionStaticParam.Msgsize() + 32 + z.DoDSettleConnectionDynamicParam.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionStaticParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "pi":
			z.ProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "scn":
			z.SrcCompanyName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcCompanyName")
				return
			}
		case "sr":
			z.SrcRegion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcRegion")
				return
			}
		case "sc":
			z.SrcCity, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcCity")
				return
			}
		case "sdc":
			z.SrcDataCenter, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcDataCenter")
				return
			}
		case "sp":
			z.SrcPort, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcPort")
				return
			}
		case "dcn":
			z.DstCompanyName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstCompanyName")
				return
			}
		case "dr":
			z.DstRegion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstRegion")
				return
			}
		case "dc":
			z.DstCity, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstCity")
				return
			}
		case "ddc":
			z.DstDataCenter, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstDataCenter")
				return
			}
		case "dp":
			z.DstPort, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstPort")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionStaticParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 11
	// write "pi"
	err = en.Append(0x8b, 0xa2, 0x70, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductId)
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	// write "scn"
	err = en.Append(0xa3, 0x73, 0x63, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcCompanyName)
	if err != nil {
		err = msgp.WrapError(err, "SrcCompanyName")
		return
	}
	// write "sr"
	err = en.Append(0xa2, 0x73, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcRegion)
	if err != nil {
		err = msgp.WrapError(err, "SrcRegion")
		return
	}
	// write "sc"
	err = en.Append(0xa2, 0x73, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcCity)
	if err != nil {
		err = msgp.WrapError(err, "SrcCity")
		return
	}
	// write "sdc"
	err = en.Append(0xa3, 0x73, 0x64, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcDataCenter)
	if err != nil {
		err = msgp.WrapError(err, "SrcDataCenter")
		return
	}
	// write "sp"
	err = en.Append(0xa2, 0x73, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcPort)
	if err != nil {
		err = msgp.WrapError(err, "SrcPort")
		return
	}
	// write "dcn"
	err = en.Append(0xa3, 0x64, 0x63, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstCompanyName)
	if err != nil {
		err = msgp.WrapError(err, "DstCompanyName")
		return
	}
	// write "dr"
	err = en.Append(0xa2, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstRegion)
	if err != nil {
		err = msgp.WrapError(err, "DstRegion")
		return
	}
	// write "dc"
	err = en.Append(0xa2, 0x64, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstCity)
	if err != nil {
		err = msgp.WrapError(err, "DstCity")
		return
	}
	// write "ddc"
	err = en.Append(0xa3, 0x64, 0x64, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstDataCenter)
	if err != nil {
		err = msgp.WrapError(err, "DstDataCenter")
		return
	}
	// write "dp"
	err = en.Append(0xa2, 0x64, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstPort)
	if err != nil {
		err = msgp.WrapError(err, "DstPort")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionStaticParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "pi"
	o = append(o, 0x8b, 0xa2, 0x70, 0x69)
	o = msgp.AppendString(o, z.ProductId)
	// string "scn"
	o = append(o, 0xa3, 0x73, 0x63, 0x6e)
	o = msgp.AppendString(o, z.SrcCompanyName)
	// string "sr"
	o = append(o, 0xa2, 0x73, 0x72)
	o = msgp.AppendString(o, z.SrcRegion)
	// string "sc"
	o = append(o, 0xa2, 0x73, 0x63)
	o = msgp.AppendString(o, z.SrcCity)
	// string "sdc"
	o = append(o, 0xa3, 0x73, 0x64, 0x63)
	o = msgp.AppendString(o, z.SrcDataCenter)
	// string "sp"
	o = append(o, 0xa2, 0x73, 0x70)
	o = msgp.AppendString(o, z.SrcPort)
	// string "dcn"
	o = append(o, 0xa3, 0x64, 0x63, 0x6e)
	o = msgp.AppendString(o, z.DstCompanyName)
	// string "dr"
	o = append(o, 0xa2, 0x64, 0x72)
	o = msgp.AppendString(o, z.DstRegion)
	// string "dc"
	o = append(o, 0xa2, 0x64, 0x63)
	o = msgp.AppendString(o, z.DstCity)
	// string "ddc"
	o = append(o, 0xa3, 0x64, 0x64, 0x63)
	o = msgp.AppendString(o, z.DstDataCenter)
	// string "dp"
	o = append(o, 0xa2, 0x64, 0x70)
	o = msgp.AppendString(o, z.DstPort)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionStaticParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "pi":
			z.ProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "scn":
			z.SrcCompanyName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcCompanyName")
				return
			}
		case "sr":
			z.SrcRegion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcRegion")
				return
			}
		case "sc":
			z.SrcCity, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcCity")
				return
			}
		case "sdc":
			z.SrcDataCenter, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcDataCenter")
				return
			}
		case "sp":
			z.SrcPort, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcPort")
				return
			}
		case "dcn":
			z.DstCompanyName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstCompanyName")
				return
			}
		case "dr":
			z.DstRegion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstRegion")
				return
			}
		case "dc":
			z.DstCity, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstCity")
				return
			}
		case "ddc":
			z.DstDataCenter, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstDataCenter")
				return
			}
		case "dp":
			z.DstPort, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstPort")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionStaticParam) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ProductId) + 4 + msgp.StringPrefixSize + len(z.SrcCompanyName) + 3 + msgp.StringPrefixSize + len(z.SrcRegion) + 3 + msgp.StringPrefixSize + len(z.SrcCity) + 4 + msgp.StringPrefixSize + len(z.SrcDataCenter) + 3 + msgp.StringPrefixSize + len(z.SrcPort) + 4 + msgp.StringPrefixSize + len(z.DstCompanyName) + 3 + msgp.StringPrefixSize + len(z.DstRegion) + 3 + msgp.StringPrefixSize + len(z.DstCity) + 4 + msgp.StringPrefixSize + len(z.DstDataCenter) + 3 + msgp.StringPrefixSize + len(z.DstPort)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleCreateOrderParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "c":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0004) {
				z.Connections = (z.Connections)[:zb0004]
			} else {
				z.Connections = make([]*DoDSettleConnectionParam, zb0004)
			}
			for za0001 := range z.Connections {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleConnectionParam)
					}
					var zb0005 uint32
					zb0005, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "DoDSettleConnectionStaticParam":
							err = z.Connections[za0001].DoDSettleConnectionStaticParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							err = z.Connections[za0001].DoDSettleConnectionDynamicParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleCreateOrderParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "b"
	err = en.Append(0x83, 0xa1, 0x62)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Connections)))
	if err != nil {
		err = msgp.WrapError(err, "Connections")
		return
	}
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "DoDSettleConnectionStaticParam"
			err = en.Append(0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionStaticParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
				return
			}
			// write "DoDSettleConnectionDynamicParam"
			err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionDynamicParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleCreateOrderParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "b"
	o = append(o, 0x83, 0xa1, 0x62)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Connections)))
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "DoDSettleConnectionStaticParam"
			o = append(o, 0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionStaticParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
				return
			}
			// string "DoDSettleConnectionDynamicParam"
			o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleCreateOrderParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "c":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0004) {
				z.Connections = (z.Connections)[:zb0004]
			} else {
				z.Connections = make([]*DoDSettleConnectionParam, zb0004)
			}
			for za0001 := range z.Connections {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleConnectionParam)
					}
					var zb0005 uint32
					zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "DoDSettleConnectionStaticParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionStaticParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleCreateOrderParam) Msgsize() (s int) {
	s = 1 + 2
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 2
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 31 + z.Connections[za0001].DoDSettleConnectionStaticParam.Msgsize() + 32 + z.Connections[za0001].DoDSettleConnectionDynamicParam.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleOrderInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "oi":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "st":
			{
				var zb0004 int
				zb0004, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "State")
					return
				}
				z.State = DoDSettleOrderState(zb0004)
			}
		case "c":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0005) {
				z.Connections = (z.Connections)[:zb0005]
			} else {
				z.Connections = make([]*DoDSettleConnectionParam, zb0005)
			}
			for za0001 := range z.Connections {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleConnectionParam)
					}
					var zb0006 uint32
					zb0006, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0006 > 0 {
						zb0006--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "DoDSettleConnectionStaticParam":
							err = z.Connections[za0001].DoDSettleConnectionStaticParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							err = z.Connections[za0001].DoDSettleConnectionDynamicParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		case "t":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Track")
				return
			}
			if cap(z.Track) >= int(zb0007) {
				z.Track = (z.Track)[:zb0007]
			} else {
				z.Track = make([]*DoDSettleOrderLifeTrack, zb0007)
			}
			for za0002 := range z.Track {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
					z.Track[za0002] = nil
				} else {
					if z.Track[za0002] == nil {
						z.Track[za0002] = new(DoDSettleOrderLifeTrack)
					}
					err = z.Track[za0002].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleOrderInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "b"
	err = en.Append(0x86, 0xa1, 0x62)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "oi"
	err = en.Append(0xa2, 0x6f, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "st"
	err = en.Append(0xa2, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.State))
	if err != nil {
		err = msgp.WrapError(err, "State")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Connections)))
	if err != nil {
		err = msgp.WrapError(err, "Connections")
		return
	}
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "DoDSettleConnectionStaticParam"
			err = en.Append(0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionStaticParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
				return
			}
			// write "DoDSettleConnectionDynamicParam"
			err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionDynamicParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Track)))
	if err != nil {
		err = msgp.WrapError(err, "Track")
		return
	}
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Track[za0002].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Track", za0002)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleOrderInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "b"
	o = append(o, 0x86, 0xa1, 0x62)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "oi"
	o = append(o, 0xa2, 0x6f, 0x69)
	o = msgp.AppendString(o, z.OrderId)
	// string "st"
	o = append(o, 0xa2, 0x73, 0x74)
	o = msgp.AppendInt(o, int(z.State))
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Connections)))
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "DoDSettleConnectionStaticParam"
			o = append(o, 0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionStaticParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
				return
			}
			// string "DoDSettleConnectionDynamicParam"
			o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Track)))
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Track[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Track", za0002)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleOrderInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "oi":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "st":
			{
				var zb0004 int
				zb0004, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "State")
					return
				}
				z.State = DoDSettleOrderState(zb0004)
			}
		case "c":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0005) {
				z.Connections = (z.Connections)[:zb0005]
			} else {
				z.Connections = make([]*DoDSettleConnectionParam, zb0005)
			}
			for za0001 := range z.Connections {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleConnectionParam)
					}
					var zb0006 uint32
					zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0006 > 0 {
						zb0006--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "DoDSettleConnectionStaticParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionStaticParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		case "t":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Track")
				return
			}
			if cap(z.Track) >= int(zb0007) {
				z.Track = (z.Track)[:zb0007]
			} else {
				z.Track = make([]*DoDSettleOrderLifeTrack, zb0007)
			}
			for za0002 := range z.Track {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Track[za0002] = nil
				} else {
					if z.Track[za0002] == nil {
						z.Track[za0002] = new(DoDSettleOrderLifeTrack)
					}
					bts, err = z.Track[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleOrderInfo) Msgsize() (s int) {
	s = 1 + 2
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 2
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 3 + msgp.StringPrefixSize + len(z.OrderId) + 3 + msgp.IntSize + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 31 + z.Connections[za0001].DoDSettleConnectionStaticParam.Msgsize() + 32 + z.Connections[za0001].DoDSettleConnectionDynamicParam.Msgsize()
		}
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Track[za0002].Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleOrderLifeTrack) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "o":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "State")
					return
				}
				z.State = DoDSettleOrderState(zb0002)
			}
		case "r":
			z.Reason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Reason")
				return
			}
		case "t":
			z.Time, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		case "h":
			err = dc.ReadExtension(&z.Hash)
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleOrderLifeTrack) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "o"
	err = en.Append(0x84, 0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.State))
	if err != nil {
		err = msgp.WrapError(err, "State")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Reason)
	if err != nil {
		err = msgp.WrapError(err, "Reason")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Time)
	if err != nil {
		err = msgp.WrapError(err, "Time")
		return
	}
	// write "h"
	err = en.Append(0xa1, 0x68)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.Hash)
	if err != nil {
		err = msgp.WrapError(err, "Hash")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleOrderLifeTrack) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "o"
	o = append(o, 0x84, 0xa1, 0x6f)
	o = msgp.AppendInt(o, int(z.State))
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendString(o, z.Reason)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt64(o, z.Time)
	// string "h"
	o = append(o, 0xa1, 0x68)
	o, err = msgp.AppendExtension(o, &z.Hash)
	if err != nil {
		err = msgp.WrapError(err, "Hash")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleOrderLifeTrack) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "o":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "State")
					return
				}
				z.State = DoDSettleOrderState(zb0002)
			}
		case "r":
			z.Reason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reason")
				return
			}
		case "t":
			z.Time, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		case "h":
			bts, err = msgp.ReadExtensionBytes(bts, &z.Hash)
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleOrderLifeTrack) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize + 2 + msgp.StringPrefixSize + len(z.Reason) + 2 + msgp.Int64Size + 2 + msgp.ExtensionPrefixSize + z.Hash.Len()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleOrderState) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleOrderState(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleOrderState) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleOrderState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleOrderState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleOrderState(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleOrderState) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleResourceReadyParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "o":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "p":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
			if cap(z.ProductId) >= int(zb0002) {
				z.ProductId = (z.ProductId)[:zb0002]
			} else {
				z.ProductId = make([]string, zb0002)
			}
			for za0001 := range z.ProductId {
				z.ProductId[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ProductId", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleResourceReadyParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "o"
	err = en.Append(0x82, 0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ProductId)))
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	for za0001 := range z.ProductId {
		err = en.WriteString(z.ProductId[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ProductId", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleResourceReadyParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "o"
	o = append(o, 0x82, 0xa1, 0x6f)
	o = msgp.AppendString(o, z.OrderId)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ProductId)))
	for za0001 := range z.ProductId {
		o = msgp.AppendString(o, z.ProductId[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleResourceReadyParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "o":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "p":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
			if cap(z.ProductId) >= int(zb0002) {
				z.ProductId = (z.ProductId)[:zb0002]
			} else {
				z.ProductId = make([]string, zb0002)
			}
			for za0001 := range z.ProductId {
				z.ProductId[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProductId", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleResourceReadyParam) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.OrderId) + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.ProductId {
		s += msgp.StringPrefixSize + len(z.ProductId[za0001])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleResponseParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Action")
					return
				}
				z.Action = DoDResponseAction(zb0002)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleResponseParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "c"
	err = en.Append(0x81, 0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.Action))
	if err != nil {
		err = msgp.WrapError(err, "Action")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleResponseParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "c"
	o = append(o, 0x81, 0xa1, 0x63)
	o = msgp.AppendInt(o, int(z.Action))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleResponseParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Action")
					return
				}
				z.Action = DoDResponseAction(zb0002)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleResponseParam) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleTerminateOrderParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "p":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
			if cap(z.ProductId) >= int(zb0004) {
				z.ProductId = (z.ProductId)[:zb0004]
			} else {
				z.ProductId = make([]string, zb0004)
			}
			for za0001 := range z.ProductId {
				z.ProductId[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ProductId", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleTerminateOrderParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "b"
	err = en.Append(0x83, 0xa1, 0x62)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ProductId)))
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	for za0001 := range z.ProductId {
		err = en.WriteString(z.ProductId[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ProductId", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleTerminateOrderParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "b"
	o = append(o, 0x83, 0xa1, 0x62)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ProductId)))
	for za0001 := range z.ProductId {
		o = msgp.AppendString(o, z.ProductId[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleTerminateOrderParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "p":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
			if cap(z.ProductId) >= int(zb0004) {
				z.ProductId = (z.ProductId)[:zb0004]
			} else {
				z.ProductId = make([]string, zb0004)
			}
			for za0001 := range z.ProductId {
				z.ProductId[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProductId", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleTerminateOrderParam) Msgsize() (s int) {
	s = 1 + 2
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 2
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0001 := range z.ProductId {
		s += msgp.StringPrefixSize + len(z.ProductId[za0001])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleUpdateOrderInfoParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			err = dc.ReadExtension(&z.InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		case "oi":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "pi":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
			if cap(z.ProductId) >= int(zb0002) {
				z.ProductId = (z.ProductId)[:zb0002]
			} else {
				z.ProductId = make([]string, zb0002)
			}
			for za0001 := range z.ProductId {
				z.ProductId[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ProductId", za0001)
					return
				}
			}
		case "o":
			{
				var zb0003 int
				zb0003, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Operation")
					return
				}
				z.Operation = DoDOrderOperation(zb0003)
			}
		case "fr":
			z.FailReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FailReason")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleUpdateOrderInfoParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "i"
	err = en.Append(0x85, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.InternalId)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	// write "oi"
	err = en.Append(0xa2, 0x6f, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "pi"
	err = en.Append(0xa2, 0x70, 0x69)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ProductId)))
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	for za0001 := range z.ProductId {
		err = en.WriteString(z.ProductId[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ProductId", za0001)
			return
		}
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.Operation))
	if err != nil {
		err = msgp.WrapError(err, "Operation")
		return
	}
	// write "fr"
	err = en.Append(0xa2, 0x66, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.FailReason)
	if err != nil {
		err = msgp.WrapError(err, "FailReason")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleUpdateOrderInfoParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "i"
	o = append(o, 0x85, 0xa1, 0x69)
	o, err = msgp.AppendExtension(o, &z.InternalId)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	// string "oi"
	o = append(o, 0xa2, 0x6f, 0x69)
	o = msgp.AppendString(o, z.OrderId)
	// string "pi"
	o = append(o, 0xa2, 0x70, 0x69)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ProductId)))
	for za0001 := range z.ProductId {
		o = msgp.AppendString(o, z.ProductId[za0001])
	}
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendInt(o, int(z.Operation))
	// string "fr"
	o = append(o, 0xa2, 0x66, 0x72)
	o = msgp.AppendString(o, z.FailReason)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleUpdateOrderInfoParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			bts, err = msgp.ReadExtensionBytes(bts, &z.InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		case "oi":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "pi":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
			if cap(z.ProductId) >= int(zb0002) {
				z.ProductId = (z.ProductId)[:zb0002]
			} else {
				z.ProductId = make([]string, zb0002)
			}
			for za0001 := range z.ProductId {
				z.ProductId[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProductId", za0001)
					return
				}
			}
		case "o":
			{
				var zb0003 int
				zb0003, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Operation")
					return
				}
				z.Operation = DoDOrderOperation(zb0003)
			}
		case "fr":
			z.FailReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailReason")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleUpdateOrderInfoParam) Msgsize() (s int) {
	s = 1 + 2 + msgp.ExtensionPrefixSize + z.InternalId.Len() + 3 + msgp.StringPrefixSize + len(z.OrderId) + 3 + msgp.ArrayHeaderSize
	for za0001 := range z.ProductId {
		s += msgp.StringPrefixSize + len(z.ProductId[za0001])
	}
	s += 2 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.FailReason)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleUser) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "a":
			err = dc.ReadExtension(&z.Address)
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		case "n":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleUser) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "a"
	err = en.Append(0x82, 0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.Address)
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleUser) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "a"
	o = append(o, 0x82, 0xa1, 0x61)
	o, err = msgp.AppendExtension(o, &z.Address)
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleUser) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "a":
			bts, err = msgp.ReadExtensionBytes(bts, &z.Address)
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		case "n":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleUser) Msgsize() (s int) {
	s = 1 + 2 + msgp.ExtensionPrefixSize + z.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Name)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleUserInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			err = dc.ReadExtension(&z.InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleUserInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "i"
	err = en.Append(0x81, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.InternalId)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleUserInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "i"
	o = append(o, 0x81, 0xa1, 0x69)
	o, err = msgp.AppendExtension(o, &z.InternalId)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleUserInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			bts, err = msgp.ReadExtensionBytes(bts, &z.InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleUserInfo) Msgsize() (s int) {
	s = 1 + 2 + msgp.ExtensionPrefixSize + z.InternalId.Len()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleUserInfos) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Infos")
				return
			}
			if cap(z.Infos) >= int(zb0002) {
				z.Infos = (z.Infos)[:zb0002]
			} else {
				z.Infos = make([]*DoDSettleUserInfo, zb0002)
			}
			for za0001 := range z.Infos {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Infos", za0001)
						return
					}
					z.Infos[za0001] = nil
				} else {
					if z.Infos[za0001] == nil {
						z.Infos[za0001] = new(DoDSettleUserInfo)
					}
					var zb0003 uint32
					zb0003, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Infos", za0001)
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Infos", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "i":
							err = dc.ReadExtension(&z.Infos[za0001].InternalId)
							if err != nil {
								err = msgp.WrapError(err, "Infos", za0001, "InternalId")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Infos", za0001)
								return
							}
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleUserInfos) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "i"
	err = en.Append(0x81, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Infos)))
	if err != nil {
		err = msgp.WrapError(err, "Infos")
		return
	}
	for za0001 := range z.Infos {
		if z.Infos[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 1
			// write "i"
			err = en.Append(0x81, 0xa1, 0x69)
			if err != nil {
				return
			}
			err = en.WriteExtension(&z.Infos[za0001].InternalId)
			if err != nil {
				err = msgp.WrapError(err, "Infos", za0001, "InternalId")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleUserInfos) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "i"
	o = append(o, 0x81, 0xa1, 0x69)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Infos)))
	for za0001 := range z.Infos {
		if z.Infos[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 1
			// string "i"
			o = append(o, 0x81, 0xa1, 0x69)
			o, err = msgp.AppendExtension(o, &z.Infos[za0001].InternalId)
			if err != nil {
				err = msgp.WrapError(err, "Infos", za0001, "InternalId")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleUserInfos) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Infos")
				return
			}
			if cap(z.Infos) >= int(zb0002) {
				z.Infos = (z.Infos)[:zb0002]
			} else {
				z.Infos = make([]*DoDSettleUserInfo, zb0002)
			}
			for za0001 := range z.Infos {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Infos[za0001] = nil
				} else {
					if z.Infos[za0001] == nil {
						z.Infos[za0001] = new(DoDSettleUserInfo)
					}
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Infos", za0001)
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Infos", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "i":
							bts, err = msgp.ReadExtensionBytes(bts, &z.Infos[za0001].InternalId)
							if err != nil {
								err = msgp.WrapError(err, "Infos", za0001, "InternalId")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Infos", za0001)
								return
							}
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleUserInfos) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Infos {
		if z.Infos[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 2 + msgp.ExtensionPrefixSize + z.Infos[za0001].InternalId.Len()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DodBillingUnit) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DodBillingUnit(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DodBillingUnit) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DodBillingUnit) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DodBillingUnit) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DodBillingUnit(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DodBillingUnit) Msgsize() (s int) {
	s = msgp.IntSize
	return
}
