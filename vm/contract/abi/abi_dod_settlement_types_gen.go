package abi

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleBillingType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleBillingType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleBillingType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleBillingType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleBillingType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleBillingType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleBillingType) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleBillingUnit) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleBillingUnit(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleBillingUnit) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleBillingUnit) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleBillingUnit) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleBillingUnit(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleBillingUnit) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleBuyerInvoice) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "OrderCount":
			z.OrderCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OrderCount")
				return
			}
		case "TotalConnectionCount":
			z.TotalConnectionCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TotalConnectionCount")
				return
			}
		case "TotalAmount":
			z.TotalAmount, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "TotalAmount")
				return
			}
		case "Currency":
			z.Currency, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "StartTime":
			z.StartTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "EndTime":
			z.EndTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		case "Buyer":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "Seller":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "Orders":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Orders")
				return
			}
			if cap(z.Orders) >= int(zb0004) {
				z.Orders = (z.Orders)[:zb0004]
			} else {
				z.Orders = make([]*DoDSettleInvoiceOrderDetail, zb0004)
			}
			for za0001 := range z.Orders {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Orders", za0001)
						return
					}
					z.Orders[za0001] = nil
				} else {
					if z.Orders[za0001] == nil {
						z.Orders[za0001] = new(DoDSettleInvoiceOrderDetail)
					}
					err = z.Orders[za0001].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Orders", za0001)
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleBuyerInvoice) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "OrderCount"
	err = en.Append(0x89, 0xaa, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.OrderCount)
	if err != nil {
		err = msgp.WrapError(err, "OrderCount")
		return
	}
	// write "TotalConnectionCount"
	err = en.Append(0xb4, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.TotalConnectionCount)
	if err != nil {
		err = msgp.WrapError(err, "TotalConnectionCount")
		return
	}
	// write "TotalAmount"
	err = en.Append(0xab, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.TotalAmount)
	if err != nil {
		err = msgp.WrapError(err, "TotalAmount")
		return
	}
	// write "Currency"
	err = en.Append(0xa8, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.Currency)
	if err != nil {
		err = msgp.WrapError(err, "Currency")
		return
	}
	// write "StartTime"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "EndTime"
	err = en.Append(0xa7, 0x45, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndTime)
	if err != nil {
		err = msgp.WrapError(err, "EndTime")
		return
	}
	// write "Buyer"
	err = en.Append(0xa5, 0x42, 0x75, 0x79, 0x65, 0x72)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "Seller"
	err = en.Append(0xa6, 0x53, 0x65, 0x6c, 0x6c, 0x65, 0x72)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "Orders"
	err = en.Append(0xa6, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Orders)))
	if err != nil {
		err = msgp.WrapError(err, "Orders")
		return
	}
	for za0001 := range z.Orders {
		if z.Orders[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Orders[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Orders", za0001)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleBuyerInvoice) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "OrderCount"
	o = append(o, 0x89, 0xaa, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.OrderCount)
	// string "TotalConnectionCount"
	o = append(o, 0xb4, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.TotalConnectionCount)
	// string "TotalAmount"
	o = append(o, 0xab, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.TotalAmount)
	// string "Currency"
	o = append(o, 0xa8, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79)
	o = msgp.AppendString(o, z.Currency)
	// string "StartTime"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.StartTime)
	// string "EndTime"
	o = append(o, 0xa7, 0x45, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.EndTime)
	// string "Buyer"
	o = append(o, 0xa5, 0x42, 0x75, 0x79, 0x65, 0x72)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "Seller"
	o = append(o, 0xa6, 0x53, 0x65, 0x6c, 0x6c, 0x65, 0x72)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "Orders"
	o = append(o, 0xa6, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Orders)))
	for za0001 := range z.Orders {
		if z.Orders[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Orders[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Orders", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleBuyerInvoice) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "OrderCount":
			z.OrderCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderCount")
				return
			}
		case "TotalConnectionCount":
			z.TotalConnectionCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalConnectionCount")
				return
			}
		case "TotalAmount":
			z.TotalAmount, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalAmount")
				return
			}
		case "Currency":
			z.Currency, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "StartTime":
			z.StartTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "EndTime":
			z.EndTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		case "Buyer":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "Seller":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "Orders":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Orders")
				return
			}
			if cap(z.Orders) >= int(zb0004) {
				z.Orders = (z.Orders)[:zb0004]
			} else {
				z.Orders = make([]*DoDSettleInvoiceOrderDetail, zb0004)
			}
			for za0001 := range z.Orders {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Orders[za0001] = nil
				} else {
					if z.Orders[za0001] == nil {
						z.Orders[za0001] = new(DoDSettleInvoiceOrderDetail)
					}
					bts, err = z.Orders[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Orders", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleBuyerInvoice) Msgsize() (s int) {
	s = 1 + 11 + msgp.IntSize + 21 + msgp.IntSize + 12 + msgp.Float64Size + 9 + msgp.StringPrefixSize + len(z.Currency) + 10 + msgp.Int64Size + 8 + msgp.Int64Size + 6
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 7
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Orders {
		if z.Orders[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Orders[za0001].Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleChangeConnectionParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "p":
			z.ProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "DoDSettleConnectionDynamicParam":
			err = z.DoDSettleConnectionDynamicParam.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleChangeConnectionParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "p"
	err = en.Append(0x82, 0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductId)
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	// write "DoDSettleConnectionDynamicParam"
	err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = z.DoDSettleConnectionDynamicParam.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleChangeConnectionParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "p"
	o = append(o, 0x82, 0xa1, 0x70)
	o = msgp.AppendString(o, z.ProductId)
	// string "DoDSettleConnectionDynamicParam"
	o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	o, err = z.DoDSettleConnectionDynamicParam.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleChangeConnectionParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "p":
			z.ProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "DoDSettleConnectionDynamicParam":
			bts, err = z.DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleChangeConnectionParam) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.ProductId) + 32 + z.DoDSettleConnectionDynamicParam.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleChangeOrderParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "c":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0004) {
				z.Connections = (z.Connections)[:zb0004]
			} else {
				z.Connections = make([]*DoDSettleChangeConnectionParam, zb0004)
			}
			for za0001 := range z.Connections {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleChangeConnectionParam)
					}
					var zb0005 uint32
					zb0005, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "p":
							z.Connections[za0001].ProductId, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "ProductId")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							err = z.Connections[za0001].DoDSettleConnectionDynamicParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleChangeOrderParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "b"
	err = en.Append(0x83, 0xa1, 0x62)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Connections)))
	if err != nil {
		err = msgp.WrapError(err, "Connections")
		return
	}
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "p"
			err = en.Append(0x82, 0xa1, 0x70)
			if err != nil {
				return
			}
			err = en.WriteString(z.Connections[za0001].ProductId)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "ProductId")
				return
			}
			// write "DoDSettleConnectionDynamicParam"
			err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionDynamicParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleChangeOrderParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "b"
	o = append(o, 0x83, 0xa1, 0x62)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Connections)))
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "p"
			o = append(o, 0x82, 0xa1, 0x70)
			o = msgp.AppendString(o, z.Connections[za0001].ProductId)
			// string "DoDSettleConnectionDynamicParam"
			o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleChangeOrderParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "c":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0004) {
				z.Connections = (z.Connections)[:zb0004]
			} else {
				z.Connections = make([]*DoDSettleChangeConnectionParam, zb0004)
			}
			for za0001 := range z.Connections {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleChangeConnectionParam)
					}
					var zb0005 uint32
					zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "p":
							z.Connections[za0001].ProductId, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "ProductId")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleChangeOrderParam) Msgsize() (s int) {
	s = 1 + 2
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 2
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 2 + msgp.StringPrefixSize + len(z.Connections[za0001].ProductId) + 32 + z.Connections[za0001].DoDSettleConnectionDynamicParam.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionActive) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "a":
			z.ActiveAt, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ActiveAt")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleConnectionActive) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "a"
	err = en.Append(0x81, 0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ActiveAt)
	if err != nil {
		err = msgp.WrapError(err, "ActiveAt")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleConnectionActive) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "a"
	o = append(o, 0x81, 0xa1, 0x61)
	o = msgp.AppendInt64(o, z.ActiveAt)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionActive) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "a":
			z.ActiveAt, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ActiveAt")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleConnectionActive) Msgsize() (s int) {
	s = 1 + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionActiveKey) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "InternalId":
			err = z.InternalId.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		case "ProductId":
			z.ProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionActiveKey) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "InternalId"
	err = en.Append(0x82, 0xaa, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x49, 0x64)
	if err != nil {
		return
	}
	err = z.InternalId.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	// write "ProductId"
	err = en.Append(0xa9, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductId)
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionActiveKey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "InternalId"
	o = append(o, 0x82, 0xaa, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x49, 0x64)
	o, err = z.InternalId.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	// string "ProductId"
	o = append(o, 0xa9, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x49, 0x64)
	o = msgp.AppendString(o, z.ProductId)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionActiveKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "InternalId":
			bts, err = z.InternalId.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		case "ProductId":
			z.ProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionActiveKey) Msgsize() (s int) {
	s = 1 + 11 + z.InternalId.Msgsize() + 10 + msgp.StringPrefixSize + len(z.ProductId)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionDynamicParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "oi":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "q":
			z.QuoteId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "QuoteId")
				return
			}
		case "qi":
			z.QuoteItemId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "QuoteItemId")
				return
			}
		case "cn":
			z.ConnectionName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ConnectionName")
				return
			}
		case "pt":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PaymentType")
					return
				}
				z.PaymentType = DoDSettlePaymentType(zb0002)
			}
		case "bt":
			{
				var zb0003 int
				zb0003, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BillingType")
					return
				}
				z.BillingType = DoDSettleBillingType(zb0003)
			}
		case "cr":
			z.Currency, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "scs":
			{
				var zb0004 int
				zb0004, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ServiceClass")
					return
				}
				z.ServiceClass = DoDSettleServiceClass(zb0004)
			}
		case "bw":
			z.Bandwidth, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bandwidth")
				return
			}
		case "bu":
			{
				var zb0005 int
				zb0005, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BillingUnit")
					return
				}
				z.BillingUnit = DoDSettleBillingUnit(zb0005)
			}
		case "p":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "ad":
			z.Addition, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Addition")
				return
			}
		case "st":
			z.StartTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "et":
			z.EndTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionDynamicParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 14
	// write "oi"
	err = en.Append(0x8e, 0xa2, 0x6f, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "q"
	err = en.Append(0xa1, 0x71)
	if err != nil {
		return
	}
	err = en.WriteString(z.QuoteId)
	if err != nil {
		err = msgp.WrapError(err, "QuoteId")
		return
	}
	// write "qi"
	err = en.Append(0xa2, 0x71, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.QuoteItemId)
	if err != nil {
		err = msgp.WrapError(err, "QuoteItemId")
		return
	}
	// write "cn"
	err = en.Append(0xa2, 0x63, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.ConnectionName)
	if err != nil {
		err = msgp.WrapError(err, "ConnectionName")
		return
	}
	// write "pt"
	err = en.Append(0xa2, 0x70, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.PaymentType))
	if err != nil {
		err = msgp.WrapError(err, "PaymentType")
		return
	}
	// write "bt"
	err = en.Append(0xa2, 0x62, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.BillingType))
	if err != nil {
		err = msgp.WrapError(err, "BillingType")
		return
	}
	// write "cr"
	err = en.Append(0xa2, 0x63, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Currency)
	if err != nil {
		err = msgp.WrapError(err, "Currency")
		return
	}
	// write "scs"
	err = en.Append(0xa3, 0x73, 0x63, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.ServiceClass))
	if err != nil {
		err = msgp.WrapError(err, "ServiceClass")
		return
	}
	// write "bw"
	err = en.Append(0xa2, 0x62, 0x77)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bandwidth)
	if err != nil {
		err = msgp.WrapError(err, "Bandwidth")
		return
	}
	// write "bu"
	err = en.Append(0xa2, 0x62, 0x75)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.BillingUnit))
	if err != nil {
		err = msgp.WrapError(err, "BillingUnit")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "ad"
	err = en.Append(0xa2, 0x61, 0x64)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Addition)
	if err != nil {
		err = msgp.WrapError(err, "Addition")
		return
	}
	// write "st"
	err = en.Append(0xa2, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "et"
	err = en.Append(0xa2, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndTime)
	if err != nil {
		err = msgp.WrapError(err, "EndTime")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionDynamicParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "oi"
	o = append(o, 0x8e, 0xa2, 0x6f, 0x69)
	o = msgp.AppendString(o, z.OrderId)
	// string "q"
	o = append(o, 0xa1, 0x71)
	o = msgp.AppendString(o, z.QuoteId)
	// string "qi"
	o = append(o, 0xa2, 0x71, 0x69)
	o = msgp.AppendString(o, z.QuoteItemId)
	// string "cn"
	o = append(o, 0xa2, 0x63, 0x6e)
	o = msgp.AppendString(o, z.ConnectionName)
	// string "pt"
	o = append(o, 0xa2, 0x70, 0x74)
	o = msgp.AppendInt(o, int(z.PaymentType))
	// string "bt"
	o = append(o, 0xa2, 0x62, 0x74)
	o = msgp.AppendInt(o, int(z.BillingType))
	// string "cr"
	o = append(o, 0xa2, 0x63, 0x72)
	o = msgp.AppendString(o, z.Currency)
	// string "scs"
	o = append(o, 0xa3, 0x73, 0x63, 0x73)
	o = msgp.AppendInt(o, int(z.ServiceClass))
	// string "bw"
	o = append(o, 0xa2, 0x62, 0x77)
	o = msgp.AppendString(o, z.Bandwidth)
	// string "bu"
	o = append(o, 0xa2, 0x62, 0x75)
	o = msgp.AppendInt(o, int(z.BillingUnit))
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendFloat64(o, z.Price)
	// string "ad"
	o = append(o, 0xa2, 0x61, 0x64)
	o = msgp.AppendFloat64(o, z.Addition)
	// string "st"
	o = append(o, 0xa2, 0x73, 0x74)
	o = msgp.AppendInt64(o, z.StartTime)
	// string "et"
	o = append(o, 0xa2, 0x65, 0x74)
	o = msgp.AppendInt64(o, z.EndTime)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionDynamicParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "oi":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "q":
			z.QuoteId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QuoteId")
				return
			}
		case "qi":
			z.QuoteItemId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QuoteItemId")
				return
			}
		case "cn":
			z.ConnectionName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ConnectionName")
				return
			}
		case "pt":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PaymentType")
					return
				}
				z.PaymentType = DoDSettlePaymentType(zb0002)
			}
		case "bt":
			{
				var zb0003 int
				zb0003, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BillingType")
					return
				}
				z.BillingType = DoDSettleBillingType(zb0003)
			}
		case "cr":
			z.Currency, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "scs":
			{
				var zb0004 int
				zb0004, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ServiceClass")
					return
				}
				z.ServiceClass = DoDSettleServiceClass(zb0004)
			}
		case "bw":
			z.Bandwidth, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bandwidth")
				return
			}
		case "bu":
			{
				var zb0005 int
				zb0005, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BillingUnit")
					return
				}
				z.BillingUnit = DoDSettleBillingUnit(zb0005)
			}
		case "p":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "ad":
			z.Addition, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Addition")
				return
			}
		case "st":
			z.StartTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "et":
			z.EndTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionDynamicParam) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.OrderId) + 2 + msgp.StringPrefixSize + len(z.QuoteId) + 3 + msgp.StringPrefixSize + len(z.QuoteItemId) + 3 + msgp.StringPrefixSize + len(z.ConnectionName) + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.Currency) + 4 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.Bandwidth) + 3 + msgp.IntSize + 2 + msgp.Float64Size + 3 + msgp.Float64Size + 3 + msgp.Int64Size + 3 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DoDSettleConnectionStaticParam":
			err = z.DoDSettleConnectionStaticParam.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
				return
			}
		case "ac":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Active")
					return
				}
				z.Active = nil
			} else {
				if z.Active == nil {
					z.Active = new(DoDSettleConnectionDynamicParam)
				}
				err = z.Active.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Active")
					return
				}
			}
		case "do":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Done")
				return
			}
			if cap(z.Done) >= int(zb0002) {
				z.Done = (z.Done)[:zb0002]
			} else {
				z.Done = make([]*DoDSettleConnectionDynamicParam, zb0002)
			}
			for za0001 := range z.Done {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Done", za0001)
						return
					}
					z.Done[za0001] = nil
				} else {
					if z.Done[za0001] == nil {
						z.Done[za0001] = new(DoDSettleConnectionDynamicParam)
					}
					err = z.Done[za0001].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Done", za0001)
						return
					}
				}
			}
		case "dis":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Disconnect")
					return
				}
				z.Disconnect = nil
			} else {
				if z.Disconnect == nil {
					z.Disconnect = new(DoDSettleDisconnectInfo)
				}
				err = z.Disconnect.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Disconnect")
					return
				}
			}
		case "t":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Track")
				return
			}
			if cap(z.Track) >= int(zb0003) {
				z.Track = (z.Track)[:zb0003]
			} else {
				z.Track = make([]*DoDSettleConnectionLifeTrack, zb0003)
			}
			for za0002 := range z.Track {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
					z.Track[za0002] = nil
				} else {
					if z.Track[za0002] == nil {
						z.Track[za0002] = new(DoDSettleConnectionLifeTrack)
					}
					err = z.Track[za0002].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "DoDSettleConnectionStaticParam"
	err = en.Append(0x85, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = z.DoDSettleConnectionStaticParam.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
		return
	}
	// write "ac"
	err = en.Append(0xa2, 0x61, 0x63)
	if err != nil {
		return
	}
	if z.Active == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Active.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Active")
			return
		}
	}
	// write "do"
	err = en.Append(0xa2, 0x64, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Done)))
	if err != nil {
		err = msgp.WrapError(err, "Done")
		return
	}
	for za0001 := range z.Done {
		if z.Done[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Done[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Done", za0001)
				return
			}
		}
	}
	// write "dis"
	err = en.Append(0xa3, 0x64, 0x69, 0x73)
	if err != nil {
		return
	}
	if z.Disconnect == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Disconnect.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Disconnect")
			return
		}
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Track)))
	if err != nil {
		err = msgp.WrapError(err, "Track")
		return
	}
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Track[za0002].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Track", za0002)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "DoDSettleConnectionStaticParam"
	o = append(o, 0x85, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	o, err = z.DoDSettleConnectionStaticParam.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
		return
	}
	// string "ac"
	o = append(o, 0xa2, 0x61, 0x63)
	if z.Active == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Active.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Active")
			return
		}
	}
	// string "do"
	o = append(o, 0xa2, 0x64, 0x6f)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Done)))
	for za0001 := range z.Done {
		if z.Done[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Done[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Done", za0001)
				return
			}
		}
	}
	// string "dis"
	o = append(o, 0xa3, 0x64, 0x69, 0x73)
	if z.Disconnect == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Disconnect.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Disconnect")
			return
		}
	}
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Track)))
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Track[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Track", za0002)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DoDSettleConnectionStaticParam":
			bts, err = z.DoDSettleConnectionStaticParam.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
				return
			}
		case "ac":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Active = nil
			} else {
				if z.Active == nil {
					z.Active = new(DoDSettleConnectionDynamicParam)
				}
				bts, err = z.Active.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Active")
					return
				}
			}
		case "do":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Done")
				return
			}
			if cap(z.Done) >= int(zb0002) {
				z.Done = (z.Done)[:zb0002]
			} else {
				z.Done = make([]*DoDSettleConnectionDynamicParam, zb0002)
			}
			for za0001 := range z.Done {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Done[za0001] = nil
				} else {
					if z.Done[za0001] == nil {
						z.Done[za0001] = new(DoDSettleConnectionDynamicParam)
					}
					bts, err = z.Done[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Done", za0001)
						return
					}
				}
			}
		case "dis":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Disconnect = nil
			} else {
				if z.Disconnect == nil {
					z.Disconnect = new(DoDSettleDisconnectInfo)
				}
				bts, err = z.Disconnect.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disconnect")
					return
				}
			}
		case "t":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Track")
				return
			}
			if cap(z.Track) >= int(zb0003) {
				z.Track = (z.Track)[:zb0003]
			} else {
				z.Track = make([]*DoDSettleConnectionLifeTrack, zb0003)
			}
			for za0002 := range z.Track {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Track[za0002] = nil
				} else {
					if z.Track[za0002] == nil {
						z.Track[za0002] = new(DoDSettleConnectionLifeTrack)
					}
					bts, err = z.Track[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionInfo) Msgsize() (s int) {
	s = 1 + 31 + z.DoDSettleConnectionStaticParam.Msgsize() + 3
	if z.Active == nil {
		s += msgp.NilSize
	} else {
		s += z.Active.Msgsize()
	}
	s += 3 + msgp.ArrayHeaderSize
	for za0001 := range z.Done {
		if z.Done[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Done[za0001].Msgsize()
		}
	}
	s += 4
	if z.Disconnect == nil {
		s += msgp.NilSize
	} else {
		s += z.Disconnect.Msgsize()
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Track[za0002].Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionLifeTrack) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ot":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OrderType")
					return
				}
				z.OrderType = DoDSettleOrderType(zb0002)
			}
		case "oi":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "t":
			z.Time, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		case "c":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Changed")
					return
				}
				z.Changed = nil
			} else {
				if z.Changed == nil {
					z.Changed = new(DoDSettleConnectionDynamicParam)
				}
				err = z.Changed.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Changed")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionLifeTrack) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "ot"
	err = en.Append(0x84, 0xa2, 0x6f, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.OrderType))
	if err != nil {
		err = msgp.WrapError(err, "OrderType")
		return
	}
	// write "oi"
	err = en.Append(0xa2, 0x6f, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Time)
	if err != nil {
		err = msgp.WrapError(err, "Time")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	if z.Changed == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Changed.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Changed")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionLifeTrack) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "ot"
	o = append(o, 0x84, 0xa2, 0x6f, 0x74)
	o = msgp.AppendInt(o, int(z.OrderType))
	// string "oi"
	o = append(o, 0xa2, 0x6f, 0x69)
	o = msgp.AppendString(o, z.OrderId)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt64(o, z.Time)
	// string "c"
	o = append(o, 0xa1, 0x63)
	if z.Changed == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Changed.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Changed")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionLifeTrack) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ot":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OrderType")
					return
				}
				z.OrderType = DoDSettleOrderType(zb0002)
			}
		case "oi":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "t":
			z.Time, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		case "c":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Changed = nil
			} else {
				if z.Changed == nil {
					z.Changed = new(DoDSettleConnectionDynamicParam)
				}
				bts, err = z.Changed.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Changed")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionLifeTrack) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.OrderId) + 2 + msgp.Int64Size + 2
	if z.Changed == nil {
		s += msgp.NilSize
	} else {
		s += z.Changed.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DoDSettleConnectionStaticParam":
			err = z.DoDSettleConnectionStaticParam.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
				return
			}
		case "DoDSettleConnectionDynamicParam":
			err = z.DoDSettleConnectionDynamicParam.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "DoDSettleConnectionStaticParam"
	err = en.Append(0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = z.DoDSettleConnectionStaticParam.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
		return
	}
	// write "DoDSettleConnectionDynamicParam"
	err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = z.DoDSettleConnectionDynamicParam.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "DoDSettleConnectionStaticParam"
	o = append(o, 0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	o, err = z.DoDSettleConnectionStaticParam.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
		return
	}
	// string "DoDSettleConnectionDynamicParam"
	o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	o, err = z.DoDSettleConnectionDynamicParam.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DoDSettleConnectionStaticParam":
			bts, err = z.DoDSettleConnectionStaticParam.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
				return
			}
		case "DoDSettleConnectionDynamicParam":
			bts, err = z.DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionParam) Msgsize() (s int) {
	s = 1 + 31 + z.DoDSettleConnectionStaticParam.Msgsize() + 32 + z.DoDSettleConnectionDynamicParam.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionRawParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ii":
			z.ItemId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ItemId")
				return
			}
		case "bp":
			z.BuyerProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BuyerProductId")
				return
			}
		case "po":
			z.ProductOfferingId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductOfferingId")
				return
			}
		case "scn":
			z.SrcCompanyName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcCompanyName")
				return
			}
		case "sr":
			z.SrcRegion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcRegion")
				return
			}
		case "sc":
			z.SrcCity, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcCity")
				return
			}
		case "sdc":
			z.SrcDataCenter, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcDataCenter")
				return
			}
		case "sp":
			z.SrcPort, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcPort")
				return
			}
		case "dcn":
			z.DstCompanyName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstCompanyName")
				return
			}
		case "dr":
			z.DstRegion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstRegion")
				return
			}
		case "dc":
			z.DstCity, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstCity")
				return
			}
		case "ddc":
			z.DstDataCenter, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstDataCenter")
				return
			}
		case "dp":
			z.DstPort, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstPort")
				return
			}
		case "cn":
			z.ConnectionName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ConnectionName")
				return
			}
		case "pt":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PaymentType")
					return
				}
				z.PaymentType = DoDSettlePaymentType(zb0002)
			}
		case "bt":
			{
				var zb0003 int
				zb0003, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BillingType")
					return
				}
				z.BillingType = DoDSettleBillingType(zb0003)
			}
		case "cr":
			z.Currency, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "scs":
			{
				var zb0004 int
				zb0004, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ServiceClass")
					return
				}
				z.ServiceClass = DoDSettleServiceClass(zb0004)
			}
		case "bw":
			z.Bandwidth, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bandwidth")
				return
			}
		case "bu":
			{
				var zb0005 int
				zb0005, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BillingUnit")
					return
				}
				z.BillingUnit = DoDSettleBillingUnit(zb0005)
			}
		case "p":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "st":
			z.StartTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "et":
			z.EndTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionRawParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 23
	// write "ii"
	err = en.Append(0xde, 0x0, 0x17, 0xa2, 0x69, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.ItemId)
	if err != nil {
		err = msgp.WrapError(err, "ItemId")
		return
	}
	// write "bp"
	err = en.Append(0xa2, 0x62, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.BuyerProductId)
	if err != nil {
		err = msgp.WrapError(err, "BuyerProductId")
		return
	}
	// write "po"
	err = en.Append(0xa2, 0x70, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductOfferingId)
	if err != nil {
		err = msgp.WrapError(err, "ProductOfferingId")
		return
	}
	// write "scn"
	err = en.Append(0xa3, 0x73, 0x63, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcCompanyName)
	if err != nil {
		err = msgp.WrapError(err, "SrcCompanyName")
		return
	}
	// write "sr"
	err = en.Append(0xa2, 0x73, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcRegion)
	if err != nil {
		err = msgp.WrapError(err, "SrcRegion")
		return
	}
	// write "sc"
	err = en.Append(0xa2, 0x73, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcCity)
	if err != nil {
		err = msgp.WrapError(err, "SrcCity")
		return
	}
	// write "sdc"
	err = en.Append(0xa3, 0x73, 0x64, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcDataCenter)
	if err != nil {
		err = msgp.WrapError(err, "SrcDataCenter")
		return
	}
	// write "sp"
	err = en.Append(0xa2, 0x73, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcPort)
	if err != nil {
		err = msgp.WrapError(err, "SrcPort")
		return
	}
	// write "dcn"
	err = en.Append(0xa3, 0x64, 0x63, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstCompanyName)
	if err != nil {
		err = msgp.WrapError(err, "DstCompanyName")
		return
	}
	// write "dr"
	err = en.Append(0xa2, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstRegion)
	if err != nil {
		err = msgp.WrapError(err, "DstRegion")
		return
	}
	// write "dc"
	err = en.Append(0xa2, 0x64, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstCity)
	if err != nil {
		err = msgp.WrapError(err, "DstCity")
		return
	}
	// write "ddc"
	err = en.Append(0xa3, 0x64, 0x64, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstDataCenter)
	if err != nil {
		err = msgp.WrapError(err, "DstDataCenter")
		return
	}
	// write "dp"
	err = en.Append(0xa2, 0x64, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstPort)
	if err != nil {
		err = msgp.WrapError(err, "DstPort")
		return
	}
	// write "cn"
	err = en.Append(0xa2, 0x63, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.ConnectionName)
	if err != nil {
		err = msgp.WrapError(err, "ConnectionName")
		return
	}
	// write "pt"
	err = en.Append(0xa2, 0x70, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.PaymentType))
	if err != nil {
		err = msgp.WrapError(err, "PaymentType")
		return
	}
	// write "bt"
	err = en.Append(0xa2, 0x62, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.BillingType))
	if err != nil {
		err = msgp.WrapError(err, "BillingType")
		return
	}
	// write "cr"
	err = en.Append(0xa2, 0x63, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Currency)
	if err != nil {
		err = msgp.WrapError(err, "Currency")
		return
	}
	// write "scs"
	err = en.Append(0xa3, 0x73, 0x63, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.ServiceClass))
	if err != nil {
		err = msgp.WrapError(err, "ServiceClass")
		return
	}
	// write "bw"
	err = en.Append(0xa2, 0x62, 0x77)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bandwidth)
	if err != nil {
		err = msgp.WrapError(err, "Bandwidth")
		return
	}
	// write "bu"
	err = en.Append(0xa2, 0x62, 0x75)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.BillingUnit))
	if err != nil {
		err = msgp.WrapError(err, "BillingUnit")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "st"
	err = en.Append(0xa2, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "et"
	err = en.Append(0xa2, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndTime)
	if err != nil {
		err = msgp.WrapError(err, "EndTime")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionRawParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 23
	// string "ii"
	o = append(o, 0xde, 0x0, 0x17, 0xa2, 0x69, 0x69)
	o = msgp.AppendString(o, z.ItemId)
	// string "bp"
	o = append(o, 0xa2, 0x62, 0x70)
	o = msgp.AppendString(o, z.BuyerProductId)
	// string "po"
	o = append(o, 0xa2, 0x70, 0x6f)
	o = msgp.AppendString(o, z.ProductOfferingId)
	// string "scn"
	o = append(o, 0xa3, 0x73, 0x63, 0x6e)
	o = msgp.AppendString(o, z.SrcCompanyName)
	// string "sr"
	o = append(o, 0xa2, 0x73, 0x72)
	o = msgp.AppendString(o, z.SrcRegion)
	// string "sc"
	o = append(o, 0xa2, 0x73, 0x63)
	o = msgp.AppendString(o, z.SrcCity)
	// string "sdc"
	o = append(o, 0xa3, 0x73, 0x64, 0x63)
	o = msgp.AppendString(o, z.SrcDataCenter)
	// string "sp"
	o = append(o, 0xa2, 0x73, 0x70)
	o = msgp.AppendString(o, z.SrcPort)
	// string "dcn"
	o = append(o, 0xa3, 0x64, 0x63, 0x6e)
	o = msgp.AppendString(o, z.DstCompanyName)
	// string "dr"
	o = append(o, 0xa2, 0x64, 0x72)
	o = msgp.AppendString(o, z.DstRegion)
	// string "dc"
	o = append(o, 0xa2, 0x64, 0x63)
	o = msgp.AppendString(o, z.DstCity)
	// string "ddc"
	o = append(o, 0xa3, 0x64, 0x64, 0x63)
	o = msgp.AppendString(o, z.DstDataCenter)
	// string "dp"
	o = append(o, 0xa2, 0x64, 0x70)
	o = msgp.AppendString(o, z.DstPort)
	// string "cn"
	o = append(o, 0xa2, 0x63, 0x6e)
	o = msgp.AppendString(o, z.ConnectionName)
	// string "pt"
	o = append(o, 0xa2, 0x70, 0x74)
	o = msgp.AppendInt(o, int(z.PaymentType))
	// string "bt"
	o = append(o, 0xa2, 0x62, 0x74)
	o = msgp.AppendInt(o, int(z.BillingType))
	// string "cr"
	o = append(o, 0xa2, 0x63, 0x72)
	o = msgp.AppendString(o, z.Currency)
	// string "scs"
	o = append(o, 0xa3, 0x73, 0x63, 0x73)
	o = msgp.AppendInt(o, int(z.ServiceClass))
	// string "bw"
	o = append(o, 0xa2, 0x62, 0x77)
	o = msgp.AppendString(o, z.Bandwidth)
	// string "bu"
	o = append(o, 0xa2, 0x62, 0x75)
	o = msgp.AppendInt(o, int(z.BillingUnit))
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendFloat64(o, z.Price)
	// string "st"
	o = append(o, 0xa2, 0x73, 0x74)
	o = msgp.AppendInt64(o, z.StartTime)
	// string "et"
	o = append(o, 0xa2, 0x65, 0x74)
	o = msgp.AppendInt64(o, z.EndTime)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionRawParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ii":
			z.ItemId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemId")
				return
			}
		case "bp":
			z.BuyerProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BuyerProductId")
				return
			}
		case "po":
			z.ProductOfferingId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductOfferingId")
				return
			}
		case "scn":
			z.SrcCompanyName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcCompanyName")
				return
			}
		case "sr":
			z.SrcRegion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcRegion")
				return
			}
		case "sc":
			z.SrcCity, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcCity")
				return
			}
		case "sdc":
			z.SrcDataCenter, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcDataCenter")
				return
			}
		case "sp":
			z.SrcPort, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcPort")
				return
			}
		case "dcn":
			z.DstCompanyName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstCompanyName")
				return
			}
		case "dr":
			z.DstRegion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstRegion")
				return
			}
		case "dc":
			z.DstCity, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstCity")
				return
			}
		case "ddc":
			z.DstDataCenter, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstDataCenter")
				return
			}
		case "dp":
			z.DstPort, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstPort")
				return
			}
		case "cn":
			z.ConnectionName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ConnectionName")
				return
			}
		case "pt":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PaymentType")
					return
				}
				z.PaymentType = DoDSettlePaymentType(zb0002)
			}
		case "bt":
			{
				var zb0003 int
				zb0003, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BillingType")
					return
				}
				z.BillingType = DoDSettleBillingType(zb0003)
			}
		case "cr":
			z.Currency, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "scs":
			{
				var zb0004 int
				zb0004, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ServiceClass")
					return
				}
				z.ServiceClass = DoDSettleServiceClass(zb0004)
			}
		case "bw":
			z.Bandwidth, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bandwidth")
				return
			}
		case "bu":
			{
				var zb0005 int
				zb0005, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BillingUnit")
					return
				}
				z.BillingUnit = DoDSettleBillingUnit(zb0005)
			}
		case "p":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "st":
			z.StartTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "et":
			z.EndTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionRawParam) Msgsize() (s int) {
	s = 3 + 3 + msgp.StringPrefixSize + len(z.ItemId) + 3 + msgp.StringPrefixSize + len(z.BuyerProductId) + 3 + msgp.StringPrefixSize + len(z.ProductOfferingId) + 4 + msgp.StringPrefixSize + len(z.SrcCompanyName) + 3 + msgp.StringPrefixSize + len(z.SrcRegion) + 3 + msgp.StringPrefixSize + len(z.SrcCity) + 4 + msgp.StringPrefixSize + len(z.SrcDataCenter) + 3 + msgp.StringPrefixSize + len(z.SrcPort) + 4 + msgp.StringPrefixSize + len(z.DstCompanyName) + 3 + msgp.StringPrefixSize + len(z.DstRegion) + 3 + msgp.StringPrefixSize + len(z.DstCity) + 4 + msgp.StringPrefixSize + len(z.DstDataCenter) + 3 + msgp.StringPrefixSize + len(z.DstPort) + 3 + msgp.StringPrefixSize + len(z.ConnectionName) + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.Currency) + 4 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.Bandwidth) + 3 + msgp.IntSize + 2 + msgp.Float64Size + 3 + msgp.Int64Size + 3 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleConnectionStaticParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ii":
			z.ItemId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ItemId")
				return
			}
		case "bp":
			z.BuyerProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BuyerProductId")
				return
			}
		case "po":
			z.ProductOfferingId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductOfferingId")
				return
			}
		case "pi":
			z.ProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "scn":
			z.SrcCompanyName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcCompanyName")
				return
			}
		case "sr":
			z.SrcRegion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcRegion")
				return
			}
		case "sc":
			z.SrcCity, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcCity")
				return
			}
		case "sdc":
			z.SrcDataCenter, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcDataCenter")
				return
			}
		case "sp":
			z.SrcPort, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SrcPort")
				return
			}
		case "dcn":
			z.DstCompanyName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstCompanyName")
				return
			}
		case "dr":
			z.DstRegion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstRegion")
				return
			}
		case "dc":
			z.DstCity, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstCity")
				return
			}
		case "ddc":
			z.DstDataCenter, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstDataCenter")
				return
			}
		case "dp":
			z.DstPort, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DstPort")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleConnectionStaticParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 14
	// write "ii"
	err = en.Append(0x8e, 0xa2, 0x69, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.ItemId)
	if err != nil {
		err = msgp.WrapError(err, "ItemId")
		return
	}
	// write "bp"
	err = en.Append(0xa2, 0x62, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.BuyerProductId)
	if err != nil {
		err = msgp.WrapError(err, "BuyerProductId")
		return
	}
	// write "po"
	err = en.Append(0xa2, 0x70, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductOfferingId)
	if err != nil {
		err = msgp.WrapError(err, "ProductOfferingId")
		return
	}
	// write "pi"
	err = en.Append(0xa2, 0x70, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductId)
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	// write "scn"
	err = en.Append(0xa3, 0x73, 0x63, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcCompanyName)
	if err != nil {
		err = msgp.WrapError(err, "SrcCompanyName")
		return
	}
	// write "sr"
	err = en.Append(0xa2, 0x73, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcRegion)
	if err != nil {
		err = msgp.WrapError(err, "SrcRegion")
		return
	}
	// write "sc"
	err = en.Append(0xa2, 0x73, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcCity)
	if err != nil {
		err = msgp.WrapError(err, "SrcCity")
		return
	}
	// write "sdc"
	err = en.Append(0xa3, 0x73, 0x64, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcDataCenter)
	if err != nil {
		err = msgp.WrapError(err, "SrcDataCenter")
		return
	}
	// write "sp"
	err = en.Append(0xa2, 0x73, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.SrcPort)
	if err != nil {
		err = msgp.WrapError(err, "SrcPort")
		return
	}
	// write "dcn"
	err = en.Append(0xa3, 0x64, 0x63, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstCompanyName)
	if err != nil {
		err = msgp.WrapError(err, "DstCompanyName")
		return
	}
	// write "dr"
	err = en.Append(0xa2, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstRegion)
	if err != nil {
		err = msgp.WrapError(err, "DstRegion")
		return
	}
	// write "dc"
	err = en.Append(0xa2, 0x64, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstCity)
	if err != nil {
		err = msgp.WrapError(err, "DstCity")
		return
	}
	// write "ddc"
	err = en.Append(0xa3, 0x64, 0x64, 0x63)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstDataCenter)
	if err != nil {
		err = msgp.WrapError(err, "DstDataCenter")
		return
	}
	// write "dp"
	err = en.Append(0xa2, 0x64, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.DstPort)
	if err != nil {
		err = msgp.WrapError(err, "DstPort")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleConnectionStaticParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "ii"
	o = append(o, 0x8e, 0xa2, 0x69, 0x69)
	o = msgp.AppendString(o, z.ItemId)
	// string "bp"
	o = append(o, 0xa2, 0x62, 0x70)
	o = msgp.AppendString(o, z.BuyerProductId)
	// string "po"
	o = append(o, 0xa2, 0x70, 0x6f)
	o = msgp.AppendString(o, z.ProductOfferingId)
	// string "pi"
	o = append(o, 0xa2, 0x70, 0x69)
	o = msgp.AppendString(o, z.ProductId)
	// string "scn"
	o = append(o, 0xa3, 0x73, 0x63, 0x6e)
	o = msgp.AppendString(o, z.SrcCompanyName)
	// string "sr"
	o = append(o, 0xa2, 0x73, 0x72)
	o = msgp.AppendString(o, z.SrcRegion)
	// string "sc"
	o = append(o, 0xa2, 0x73, 0x63)
	o = msgp.AppendString(o, z.SrcCity)
	// string "sdc"
	o = append(o, 0xa3, 0x73, 0x64, 0x63)
	o = msgp.AppendString(o, z.SrcDataCenter)
	// string "sp"
	o = append(o, 0xa2, 0x73, 0x70)
	o = msgp.AppendString(o, z.SrcPort)
	// string "dcn"
	o = append(o, 0xa3, 0x64, 0x63, 0x6e)
	o = msgp.AppendString(o, z.DstCompanyName)
	// string "dr"
	o = append(o, 0xa2, 0x64, 0x72)
	o = msgp.AppendString(o, z.DstRegion)
	// string "dc"
	o = append(o, 0xa2, 0x64, 0x63)
	o = msgp.AppendString(o, z.DstCity)
	// string "ddc"
	o = append(o, 0xa3, 0x64, 0x64, 0x63)
	o = msgp.AppendString(o, z.DstDataCenter)
	// string "dp"
	o = append(o, 0xa2, 0x64, 0x70)
	o = msgp.AppendString(o, z.DstPort)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleConnectionStaticParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ii":
			z.ItemId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemId")
				return
			}
		case "bp":
			z.BuyerProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BuyerProductId")
				return
			}
		case "po":
			z.ProductOfferingId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductOfferingId")
				return
			}
		case "pi":
			z.ProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "scn":
			z.SrcCompanyName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcCompanyName")
				return
			}
		case "sr":
			z.SrcRegion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcRegion")
				return
			}
		case "sc":
			z.SrcCity, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcCity")
				return
			}
		case "sdc":
			z.SrcDataCenter, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcDataCenter")
				return
			}
		case "sp":
			z.SrcPort, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SrcPort")
				return
			}
		case "dcn":
			z.DstCompanyName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstCompanyName")
				return
			}
		case "dr":
			z.DstRegion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstRegion")
				return
			}
		case "dc":
			z.DstCity, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstCity")
				return
			}
		case "ddc":
			z.DstDataCenter, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstDataCenter")
				return
			}
		case "dp":
			z.DstPort, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DstPort")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleConnectionStaticParam) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ItemId) + 3 + msgp.StringPrefixSize + len(z.BuyerProductId) + 3 + msgp.StringPrefixSize + len(z.ProductOfferingId) + 3 + msgp.StringPrefixSize + len(z.ProductId) + 4 + msgp.StringPrefixSize + len(z.SrcCompanyName) + 3 + msgp.StringPrefixSize + len(z.SrcRegion) + 3 + msgp.StringPrefixSize + len(z.SrcCity) + 4 + msgp.StringPrefixSize + len(z.SrcDataCenter) + 3 + msgp.StringPrefixSize + len(z.SrcPort) + 4 + msgp.StringPrefixSize + len(z.DstCompanyName) + 3 + msgp.StringPrefixSize + len(z.DstRegion) + 3 + msgp.StringPrefixSize + len(z.DstCity) + 4 + msgp.StringPrefixSize + len(z.DstDataCenter) + 3 + msgp.StringPrefixSize + len(z.DstPort)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleContractState) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleContractState(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleContractState) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleContractState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleContractState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleContractState(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleContractState) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleCreateOrderParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "c":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0004) {
				z.Connections = (z.Connections)[:zb0004]
			} else {
				z.Connections = make([]*DoDSettleConnectionParam, zb0004)
			}
			for za0001 := range z.Connections {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleConnectionParam)
					}
					var zb0005 uint32
					zb0005, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "DoDSettleConnectionStaticParam":
							err = z.Connections[za0001].DoDSettleConnectionStaticParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							err = z.Connections[za0001].DoDSettleConnectionDynamicParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleCreateOrderParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "b"
	err = en.Append(0x83, 0xa1, 0x62)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Connections)))
	if err != nil {
		err = msgp.WrapError(err, "Connections")
		return
	}
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "DoDSettleConnectionStaticParam"
			err = en.Append(0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionStaticParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
				return
			}
			// write "DoDSettleConnectionDynamicParam"
			err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionDynamicParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleCreateOrderParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "b"
	o = append(o, 0x83, 0xa1, 0x62)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Connections)))
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "DoDSettleConnectionStaticParam"
			o = append(o, 0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionStaticParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
				return
			}
			// string "DoDSettleConnectionDynamicParam"
			o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleCreateOrderParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "c":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0004) {
				z.Connections = (z.Connections)[:zb0004]
			} else {
				z.Connections = make([]*DoDSettleConnectionParam, zb0004)
			}
			for za0001 := range z.Connections {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleConnectionParam)
					}
					var zb0005 uint32
					zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "DoDSettleConnectionStaticParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionStaticParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleCreateOrderParam) Msgsize() (s int) {
	s = 1 + 2
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 2
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 31 + z.Connections[za0001].DoDSettleConnectionStaticParam.Msgsize() + 32 + z.Connections[za0001].DoDSettleConnectionDynamicParam.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleDisconnectInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "oi":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "q":
			z.QuoteId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "QuoteId")
				return
			}
		case "qi":
			z.QuoteItemId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "QuoteItemId")
				return
			}
		case "p":
			z.Price, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "cr":
			z.Currency, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "d":
			z.DisconnectAt, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DisconnectAt")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleDisconnectInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "oi"
	err = en.Append(0x86, 0xa2, 0x6f, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "q"
	err = en.Append(0xa1, 0x71)
	if err != nil {
		return
	}
	err = en.WriteString(z.QuoteId)
	if err != nil {
		err = msgp.WrapError(err, "QuoteId")
		return
	}
	// write "qi"
	err = en.Append(0xa2, 0x71, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.QuoteItemId)
	if err != nil {
		err = msgp.WrapError(err, "QuoteItemId")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Price)
	if err != nil {
		err = msgp.WrapError(err, "Price")
		return
	}
	// write "cr"
	err = en.Append(0xa2, 0x63, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Currency)
	if err != nil {
		err = msgp.WrapError(err, "Currency")
		return
	}
	// write "d"
	err = en.Append(0xa1, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DisconnectAt)
	if err != nil {
		err = msgp.WrapError(err, "DisconnectAt")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleDisconnectInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "oi"
	o = append(o, 0x86, 0xa2, 0x6f, 0x69)
	o = msgp.AppendString(o, z.OrderId)
	// string "q"
	o = append(o, 0xa1, 0x71)
	o = msgp.AppendString(o, z.QuoteId)
	// string "qi"
	o = append(o, 0xa2, 0x71, 0x69)
	o = msgp.AppendString(o, z.QuoteItemId)
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendFloat64(o, z.Price)
	// string "cr"
	o = append(o, 0xa2, 0x63, 0x72)
	o = msgp.AppendString(o, z.Currency)
	// string "d"
	o = append(o, 0xa1, 0x64)
	o = msgp.AppendInt64(o, z.DisconnectAt)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleDisconnectInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "oi":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "q":
			z.QuoteId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QuoteId")
				return
			}
		case "qi":
			z.QuoteItemId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QuoteItemId")
				return
			}
		case "p":
			z.Price, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Price")
				return
			}
		case "cr":
			z.Currency, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "d":
			z.DisconnectAt, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisconnectAt")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleDisconnectInfo) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.OrderId) + 2 + msgp.StringPrefixSize + len(z.QuoteId) + 3 + msgp.StringPrefixSize + len(z.QuoteItemId) + 2 + msgp.Float64Size + 3 + msgp.StringPrefixSize + len(z.Currency) + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleInternalIdWrap) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			err = dc.ReadExtension(&z.InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleInternalIdWrap) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "i"
	err = en.Append(0x81, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.InternalId)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleInternalIdWrap) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "i"
	o = append(o, 0x81, 0xa1, 0x69)
	o, err = msgp.AppendExtension(o, &z.InternalId)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleInternalIdWrap) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			bts, err = msgp.ReadExtensionBytes(bts, &z.InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleInternalIdWrap) Msgsize() (s int) {
	s = 1 + 2 + msgp.ExtensionPrefixSize + z.InternalId.Len()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleInvoiceConnDetail) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ConnectionAmount":
			z.ConnectionAmount, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ConnectionAmount")
				return
			}
		case "DoDSettleConnectionStaticParam":
			err = z.DoDSettleConnectionStaticParam.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
				return
			}
		case "Usage":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Usage")
				return
			}
			if cap(z.Usage) >= int(zb0002) {
				z.Usage = (z.Usage)[:zb0002]
			} else {
				z.Usage = make([]*DoDSettleInvoiceConnDynamic, zb0002)
			}
			for za0001 := range z.Usage {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Usage", za0001)
						return
					}
					z.Usage[za0001] = nil
				} else {
					if z.Usage[za0001] == nil {
						z.Usage[za0001] = new(DoDSettleInvoiceConnDynamic)
					}
					err = z.Usage[za0001].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Usage", za0001)
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleInvoiceConnDetail) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "ConnectionAmount"
	err = en.Append(0x83, 0xb0, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.ConnectionAmount)
	if err != nil {
		err = msgp.WrapError(err, "ConnectionAmount")
		return
	}
	// write "DoDSettleConnectionStaticParam"
	err = en.Append(0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = z.DoDSettleConnectionStaticParam.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
		return
	}
	// write "Usage"
	err = en.Append(0xa5, 0x55, 0x73, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Usage)))
	if err != nil {
		err = msgp.WrapError(err, "Usage")
		return
	}
	for za0001 := range z.Usage {
		if z.Usage[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Usage[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Usage", za0001)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleInvoiceConnDetail) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "ConnectionAmount"
	o = append(o, 0x83, 0xb0, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.ConnectionAmount)
	// string "DoDSettleConnectionStaticParam"
	o = append(o, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	o, err = z.DoDSettleConnectionStaticParam.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
		return
	}
	// string "Usage"
	o = append(o, 0xa5, 0x55, 0x73, 0x61, 0x67, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Usage)))
	for za0001 := range z.Usage {
		if z.Usage[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Usage[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Usage", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleInvoiceConnDetail) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ConnectionAmount":
			z.ConnectionAmount, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ConnectionAmount")
				return
			}
		case "DoDSettleConnectionStaticParam":
			bts, err = z.DoDSettleConnectionStaticParam.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionStaticParam")
				return
			}
		case "Usage":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Usage")
				return
			}
			if cap(z.Usage) >= int(zb0002) {
				z.Usage = (z.Usage)[:zb0002]
			} else {
				z.Usage = make([]*DoDSettleInvoiceConnDynamic, zb0002)
			}
			for za0001 := range z.Usage {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Usage[za0001] = nil
				} else {
					if z.Usage[za0001] == nil {
						z.Usage[za0001] = new(DoDSettleInvoiceConnDynamic)
					}
					bts, err = z.Usage[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Usage", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleInvoiceConnDetail) Msgsize() (s int) {
	s = 1 + 17 + msgp.Float64Size + 31 + z.DoDSettleConnectionStaticParam.Msgsize() + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Usage {
		if z.Usage[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Usage[za0001].Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleInvoiceConnDynamic) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DoDSettleConnectionDynamicParam":
			err = z.DoDSettleConnectionDynamicParam.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
				return
			}
		case "InvoiceStartTime":
			z.InvoiceStartTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "InvoiceStartTime")
				return
			}
		case "InvoiceStartTimeStr":
			z.InvoiceStartTimeStr, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "InvoiceStartTimeStr")
				return
			}
		case "InvoiceEndTime":
			z.InvoiceEndTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "InvoiceEndTime")
				return
			}
		case "InvoiceEndTimeStr":
			z.InvoiceEndTimeStr, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "InvoiceEndTimeStr")
				return
			}
		case "InvoiceUnitCount":
			z.InvoiceUnitCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "InvoiceUnitCount")
				return
			}
		case "OrderType":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OrderType")
					return
				}
				z.OrderType = DoDSettleOrderType(zb0002)
			}
		case "Amount":
			z.Amount, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Amount")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleInvoiceConnDynamic) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "DoDSettleConnectionDynamicParam"
	err = en.Append(0x88, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = z.DoDSettleConnectionDynamicParam.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
		return
	}
	// write "InvoiceStartTime"
	err = en.Append(0xb0, 0x49, 0x6e, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.InvoiceStartTime)
	if err != nil {
		err = msgp.WrapError(err, "InvoiceStartTime")
		return
	}
	// write "InvoiceStartTimeStr"
	err = en.Append(0xb3, 0x49, 0x6e, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x74, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.InvoiceStartTimeStr)
	if err != nil {
		err = msgp.WrapError(err, "InvoiceStartTimeStr")
		return
	}
	// write "InvoiceEndTime"
	err = en.Append(0xae, 0x49, 0x6e, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.InvoiceEndTime)
	if err != nil {
		err = msgp.WrapError(err, "InvoiceEndTime")
		return
	}
	// write "InvoiceEndTimeStr"
	err = en.Append(0xb1, 0x49, 0x6e, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x74, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.InvoiceEndTimeStr)
	if err != nil {
		err = msgp.WrapError(err, "InvoiceEndTimeStr")
		return
	}
	// write "InvoiceUnitCount"
	err = en.Append(0xb0, 0x49, 0x6e, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x55, 0x6e, 0x69, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.InvoiceUnitCount)
	if err != nil {
		err = msgp.WrapError(err, "InvoiceUnitCount")
		return
	}
	// write "OrderType"
	err = en.Append(0xa9, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.OrderType))
	if err != nil {
		err = msgp.WrapError(err, "OrderType")
		return
	}
	// write "Amount"
	err = en.Append(0xa6, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Amount)
	if err != nil {
		err = msgp.WrapError(err, "Amount")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleInvoiceConnDynamic) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "DoDSettleConnectionDynamicParam"
	o = append(o, 0x88, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
	o, err = z.DoDSettleConnectionDynamicParam.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
		return
	}
	// string "InvoiceStartTime"
	o = append(o, 0xb0, 0x49, 0x6e, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.InvoiceStartTime)
	// string "InvoiceStartTimeStr"
	o = append(o, 0xb3, 0x49, 0x6e, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x74, 0x72)
	o = msgp.AppendString(o, z.InvoiceStartTimeStr)
	// string "InvoiceEndTime"
	o = append(o, 0xae, 0x49, 0x6e, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.InvoiceEndTime)
	// string "InvoiceEndTimeStr"
	o = append(o, 0xb1, 0x49, 0x6e, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x45, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x74, 0x72)
	o = msgp.AppendString(o, z.InvoiceEndTimeStr)
	// string "InvoiceUnitCount"
	o = append(o, 0xb0, 0x49, 0x6e, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x55, 0x6e, 0x69, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.InvoiceUnitCount)
	// string "OrderType"
	o = append(o, 0xa9, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendInt(o, int(z.OrderType))
	// string "Amount"
	o = append(o, 0xa6, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.Amount)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleInvoiceConnDynamic) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DoDSettleConnectionDynamicParam":
			bts, err = z.DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "DoDSettleConnectionDynamicParam")
				return
			}
		case "InvoiceStartTime":
			z.InvoiceStartTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InvoiceStartTime")
				return
			}
		case "InvoiceStartTimeStr":
			z.InvoiceStartTimeStr, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InvoiceStartTimeStr")
				return
			}
		case "InvoiceEndTime":
			z.InvoiceEndTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InvoiceEndTime")
				return
			}
		case "InvoiceEndTimeStr":
			z.InvoiceEndTimeStr, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InvoiceEndTimeStr")
				return
			}
		case "InvoiceUnitCount":
			z.InvoiceUnitCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InvoiceUnitCount")
				return
			}
		case "OrderType":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OrderType")
					return
				}
				z.OrderType = DoDSettleOrderType(zb0002)
			}
		case "Amount":
			z.Amount, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Amount")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleInvoiceConnDynamic) Msgsize() (s int) {
	s = 1 + 32 + z.DoDSettleConnectionDynamicParam.Msgsize() + 17 + msgp.Int64Size + 20 + msgp.StringPrefixSize + len(z.InvoiceStartTimeStr) + 15 + msgp.Int64Size + 18 + msgp.StringPrefixSize + len(z.InvoiceEndTimeStr) + 17 + msgp.IntSize + 10 + msgp.IntSize + 7 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleInvoiceOrderDetail) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "OrderId":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "ConnectionCount":
			z.ConnectionCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ConnectionCount")
				return
			}
		case "OrderAmount":
			z.OrderAmount, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "OrderAmount")
				return
			}
		case "Connections":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0002) {
				z.Connections = (z.Connections)[:zb0002]
			} else {
				z.Connections = make([]*DoDSettleInvoiceConnDetail, zb0002)
			}
			for za0001 := range z.Connections {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleInvoiceConnDetail)
					}
					err = z.Connections[za0001].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleInvoiceOrderDetail) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "OrderId"
	err = en.Append(0x84, 0xa7, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "ConnectionCount"
	err = en.Append(0xaf, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ConnectionCount)
	if err != nil {
		err = msgp.WrapError(err, "ConnectionCount")
		return
	}
	// write "OrderAmount"
	err = en.Append(0xab, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.OrderAmount)
	if err != nil {
		err = msgp.WrapError(err, "OrderAmount")
		return
	}
	// write "Connections"
	err = en.Append(0xab, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Connections)))
	if err != nil {
		err = msgp.WrapError(err, "Connections")
		return
	}
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Connections[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleInvoiceOrderDetail) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "OrderId"
	o = append(o, 0x84, 0xa7, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64)
	o = msgp.AppendString(o, z.OrderId)
	// string "ConnectionCount"
	o = append(o, 0xaf, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.ConnectionCount)
	// string "OrderAmount"
	o = append(o, 0xab, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.OrderAmount)
	// string "Connections"
	o = append(o, 0xab, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Connections)))
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Connections[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleInvoiceOrderDetail) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "OrderId":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "ConnectionCount":
			z.ConnectionCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ConnectionCount")
				return
			}
		case "OrderAmount":
			z.OrderAmount, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderAmount")
				return
			}
		case "Connections":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0002) {
				z.Connections = (z.Connections)[:zb0002]
			} else {
				z.Connections = make([]*DoDSettleInvoiceConnDetail, zb0002)
			}
			for za0001 := range z.Connections {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleInvoiceConnDetail)
					}
					bts, err = z.Connections[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleInvoiceOrderDetail) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.OrderId) + 16 + msgp.IntSize + 12 + msgp.Float64Size + 12 + msgp.ArrayHeaderSize
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Connections[za0001].Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleOrder) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			err = dc.ReadExtension(&z.Seller)
			if err != nil {
				err = msgp.WrapError(err, "Seller")
				return
			}
		case "o":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleOrder) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "s"
	err = en.Append(0x82, 0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.Seller)
	if err != nil {
		err = msgp.WrapError(err, "Seller")
		return
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleOrder) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "s"
	o = append(o, 0x82, 0xa1, 0x73)
	o, err = msgp.AppendExtension(o, &z.Seller)
	if err != nil {
		err = msgp.WrapError(err, "Seller")
		return
	}
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendString(o, z.OrderId)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleOrder) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			bts, err = msgp.ReadExtensionBytes(bts, &z.Seller)
			if err != nil {
				err = msgp.WrapError(err, "Seller")
				return
			}
		case "o":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleOrder) Msgsize() (s int) {
	s = 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Len() + 2 + msgp.StringPrefixSize + len(z.OrderId)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleOrderInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "oi":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "ot":
			{
				var zb0004 int
				zb0004, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OrderType")
					return
				}
				z.OrderType = DoDSettleOrderType(zb0004)
			}
		case "os":
			{
				var zb0005 int
				zb0005, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OrderState")
					return
				}
				z.OrderState = DoDSettleOrderState(zb0005)
			}
		case "cs":
			{
				var zb0006 int
				zb0006, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ContractState")
					return
				}
				z.ContractState = DoDSettleContractState(zb0006)
			}
		case "c":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0007) {
				z.Connections = (z.Connections)[:zb0007]
			} else {
				z.Connections = make([]*DoDSettleConnectionParam, zb0007)
			}
			for za0001 := range z.Connections {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleConnectionParam)
					}
					var zb0008 uint32
					zb0008, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0008 > 0 {
						zb0008--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "DoDSettleConnectionStaticParam":
							err = z.Connections[za0001].DoDSettleConnectionStaticParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							err = z.Connections[za0001].DoDSettleConnectionDynamicParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		case "t":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Track")
				return
			}
			if cap(z.Track) >= int(zb0009) {
				z.Track = (z.Track)[:zb0009]
			} else {
				z.Track = make([]*DoDSettleOrderLifeTrack, zb0009)
			}
			for za0002 := range z.Track {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
					z.Track[za0002] = nil
				} else {
					if z.Track[za0002] == nil {
						z.Track[za0002] = new(DoDSettleOrderLifeTrack)
					}
					err = z.Track[za0002].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleOrderInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "b"
	err = en.Append(0x88, 0xa1, 0x62)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "oi"
	err = en.Append(0xa2, 0x6f, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "ot"
	err = en.Append(0xa2, 0x6f, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.OrderType))
	if err != nil {
		err = msgp.WrapError(err, "OrderType")
		return
	}
	// write "os"
	err = en.Append(0xa2, 0x6f, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.OrderState))
	if err != nil {
		err = msgp.WrapError(err, "OrderState")
		return
	}
	// write "cs"
	err = en.Append(0xa2, 0x63, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.ContractState))
	if err != nil {
		err = msgp.WrapError(err, "ContractState")
		return
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Connections)))
	if err != nil {
		err = msgp.WrapError(err, "Connections")
		return
	}
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "DoDSettleConnectionStaticParam"
			err = en.Append(0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionStaticParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
				return
			}
			// write "DoDSettleConnectionDynamicParam"
			err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionDynamicParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Track)))
	if err != nil {
		err = msgp.WrapError(err, "Track")
		return
	}
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Track[za0002].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Track", za0002)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleOrderInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "b"
	o = append(o, 0x88, 0xa1, 0x62)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "oi"
	o = append(o, 0xa2, 0x6f, 0x69)
	o = msgp.AppendString(o, z.OrderId)
	// string "ot"
	o = append(o, 0xa2, 0x6f, 0x74)
	o = msgp.AppendInt(o, int(z.OrderType))
	// string "os"
	o = append(o, 0xa2, 0x6f, 0x73)
	o = msgp.AppendInt(o, int(z.OrderState))
	// string "cs"
	o = append(o, 0xa2, 0x63, 0x73)
	o = msgp.AppendInt(o, int(z.ContractState))
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Connections)))
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "DoDSettleConnectionStaticParam"
			o = append(o, 0x82, 0xbe, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionStaticParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
				return
			}
			// string "DoDSettleConnectionDynamicParam"
			o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Track)))
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Track[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Track", za0002)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleOrderInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "oi":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "ot":
			{
				var zb0004 int
				zb0004, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OrderType")
					return
				}
				z.OrderType = DoDSettleOrderType(zb0004)
			}
		case "os":
			{
				var zb0005 int
				zb0005, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OrderState")
					return
				}
				z.OrderState = DoDSettleOrderState(zb0005)
			}
		case "cs":
			{
				var zb0006 int
				zb0006, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ContractState")
					return
				}
				z.ContractState = DoDSettleContractState(zb0006)
			}
		case "c":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0007) {
				z.Connections = (z.Connections)[:zb0007]
			} else {
				z.Connections = make([]*DoDSettleConnectionParam, zb0007)
			}
			for za0001 := range z.Connections {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleConnectionParam)
					}
					var zb0008 uint32
					zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0008 > 0 {
						zb0008--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "DoDSettleConnectionStaticParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionStaticParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionStaticParam")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		case "t":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Track")
				return
			}
			if cap(z.Track) >= int(zb0009) {
				z.Track = (z.Track)[:zb0009]
			} else {
				z.Track = make([]*DoDSettleOrderLifeTrack, zb0009)
			}
			for za0002 := range z.Track {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Track[za0002] = nil
				} else {
					if z.Track[za0002] == nil {
						z.Track[za0002] = new(DoDSettleOrderLifeTrack)
					}
					bts, err = z.Track[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Track", za0002)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleOrderInfo) Msgsize() (s int) {
	s = 1 + 2
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 2
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 3 + msgp.StringPrefixSize + len(z.OrderId) + 3 + msgp.IntSize + 3 + msgp.IntSize + 3 + msgp.IntSize + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 31 + z.Connections[za0001].DoDSettleConnectionStaticParam.Msgsize() + 32 + z.Connections[za0001].DoDSettleConnectionDynamicParam.Msgsize()
		}
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0002 := range z.Track {
		if z.Track[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Track[za0002].Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleOrderInvoice) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "TotalConnectionCount":
			z.TotalConnectionCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TotalConnectionCount")
				return
			}
		case "TotalAmount":
			z.TotalAmount, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "TotalAmount")
				return
			}
		case "Currency":
			z.Currency, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "StartTime":
			z.StartTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "EndTime":
			z.EndTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		case "Buyer":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "Seller":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "Order":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Order")
					return
				}
				z.Order = nil
			} else {
				if z.Order == nil {
					z.Order = new(DoDSettleInvoiceOrderDetail)
				}
				err = z.Order.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Order")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleOrderInvoice) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "TotalConnectionCount"
	err = en.Append(0x88, 0xb4, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.TotalConnectionCount)
	if err != nil {
		err = msgp.WrapError(err, "TotalConnectionCount")
		return
	}
	// write "TotalAmount"
	err = en.Append(0xab, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.TotalAmount)
	if err != nil {
		err = msgp.WrapError(err, "TotalAmount")
		return
	}
	// write "Currency"
	err = en.Append(0xa8, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.Currency)
	if err != nil {
		err = msgp.WrapError(err, "Currency")
		return
	}
	// write "StartTime"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "EndTime"
	err = en.Append(0xa7, 0x45, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndTime)
	if err != nil {
		err = msgp.WrapError(err, "EndTime")
		return
	}
	// write "Buyer"
	err = en.Append(0xa5, 0x42, 0x75, 0x79, 0x65, 0x72)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "Seller"
	err = en.Append(0xa6, 0x53, 0x65, 0x6c, 0x6c, 0x65, 0x72)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "Order"
	err = en.Append(0xa5, 0x4f, 0x72, 0x64, 0x65, 0x72)
	if err != nil {
		return
	}
	if z.Order == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Order.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Order")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleOrderInvoice) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "TotalConnectionCount"
	o = append(o, 0x88, 0xb4, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.TotalConnectionCount)
	// string "TotalAmount"
	o = append(o, 0xab, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.TotalAmount)
	// string "Currency"
	o = append(o, 0xa8, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79)
	o = msgp.AppendString(o, z.Currency)
	// string "StartTime"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.StartTime)
	// string "EndTime"
	o = append(o, 0xa7, 0x45, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.EndTime)
	// string "Buyer"
	o = append(o, 0xa5, 0x42, 0x75, 0x79, 0x65, 0x72)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "Seller"
	o = append(o, 0xa6, 0x53, 0x65, 0x6c, 0x6c, 0x65, 0x72)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "Order"
	o = append(o, 0xa5, 0x4f, 0x72, 0x64, 0x65, 0x72)
	if z.Order == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Order.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Order")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleOrderInvoice) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "TotalConnectionCount":
			z.TotalConnectionCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalConnectionCount")
				return
			}
		case "TotalAmount":
			z.TotalAmount, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalAmount")
				return
			}
		case "Currency":
			z.Currency, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "StartTime":
			z.StartTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "EndTime":
			z.EndTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		case "Buyer":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "Seller":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "Order":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Order = nil
			} else {
				if z.Order == nil {
					z.Order = new(DoDSettleInvoiceOrderDetail)
				}
				bts, err = z.Order.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Order")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleOrderInvoice) Msgsize() (s int) {
	s = 1 + 21 + msgp.IntSize + 12 + msgp.Float64Size + 9 + msgp.StringPrefixSize + len(z.Currency) + 10 + msgp.Int64Size + 8 + msgp.Int64Size + 6
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 7
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 6
	if z.Order == nil {
		s += msgp.NilSize
	} else {
		s += z.Order.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleOrderLifeTrack) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cs":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ContractState")
					return
				}
				z.ContractState = DoDSettleContractState(zb0002)
			}
		case "os":
			{
				var zb0003 int
				zb0003, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OrderState")
					return
				}
				z.OrderState = DoDSettleOrderState(zb0003)
			}
		case "r":
			z.Reason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Reason")
				return
			}
		case "t":
			z.Time, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		case "h":
			err = dc.ReadExtension(&z.Hash)
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleOrderLifeTrack) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "cs"
	err = en.Append(0x85, 0xa2, 0x63, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.ContractState))
	if err != nil {
		err = msgp.WrapError(err, "ContractState")
		return
	}
	// write "os"
	err = en.Append(0xa2, 0x6f, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.OrderState))
	if err != nil {
		err = msgp.WrapError(err, "OrderState")
		return
	}
	// write "r"
	err = en.Append(0xa1, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Reason)
	if err != nil {
		err = msgp.WrapError(err, "Reason")
		return
	}
	// write "t"
	err = en.Append(0xa1, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Time)
	if err != nil {
		err = msgp.WrapError(err, "Time")
		return
	}
	// write "h"
	err = en.Append(0xa1, 0x68)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.Hash)
	if err != nil {
		err = msgp.WrapError(err, "Hash")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleOrderLifeTrack) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "cs"
	o = append(o, 0x85, 0xa2, 0x63, 0x73)
	o = msgp.AppendInt(o, int(z.ContractState))
	// string "os"
	o = append(o, 0xa2, 0x6f, 0x73)
	o = msgp.AppendInt(o, int(z.OrderState))
	// string "r"
	o = append(o, 0xa1, 0x72)
	o = msgp.AppendString(o, z.Reason)
	// string "t"
	o = append(o, 0xa1, 0x74)
	o = msgp.AppendInt64(o, z.Time)
	// string "h"
	o = append(o, 0xa1, 0x68)
	o, err = msgp.AppendExtension(o, &z.Hash)
	if err != nil {
		err = msgp.WrapError(err, "Hash")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleOrderLifeTrack) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "cs":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ContractState")
					return
				}
				z.ContractState = DoDSettleContractState(zb0002)
			}
		case "os":
			{
				var zb0003 int
				zb0003, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OrderState")
					return
				}
				z.OrderState = DoDSettleOrderState(zb0003)
			}
		case "r":
			z.Reason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Reason")
				return
			}
		case "t":
			z.Time, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		case "h":
			bts, err = msgp.ReadExtensionBytes(bts, &z.Hash)
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleOrderLifeTrack) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 3 + msgp.IntSize + 2 + msgp.StringPrefixSize + len(z.Reason) + 2 + msgp.Int64Size + 2 + msgp.ExtensionPrefixSize + z.Hash.Len()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleOrderState) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleOrderState(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleOrderState) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleOrderState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleOrderState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleOrderState(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleOrderState) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleOrderType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleOrderType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleOrderType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleOrderType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleOrderType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleOrderType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleOrderType) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettlePAYGTimeSpan) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			z.StartTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "e":
			z.EndTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettlePAYGTimeSpan) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "s"
	err = en.Append(0x82, 0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "e"
	err = en.Append(0xa1, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndTime)
	if err != nil {
		err = msgp.WrapError(err, "EndTime")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettlePAYGTimeSpan) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "s"
	o = append(o, 0x82, 0xa1, 0x73)
	o = msgp.AppendInt64(o, z.StartTime)
	// string "e"
	o = append(o, 0xa1, 0x65)
	o = msgp.AppendInt64(o, z.EndTime)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettlePAYGTimeSpan) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			z.StartTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "e":
			z.EndTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettlePAYGTimeSpan) Msgsize() (s int) {
	s = 1 + 2 + msgp.Int64Size + 2 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettlePAYGTimeSpanKey) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ProductId":
			z.ProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "OrderId":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettlePAYGTimeSpanKey) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "ProductId"
	err = en.Append(0x82, 0xa9, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductId)
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	// write "OrderId"
	err = en.Append(0xa7, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettlePAYGTimeSpanKey) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "ProductId"
	o = append(o, 0x82, 0xa9, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x49, 0x64)
	o = msgp.AppendString(o, z.ProductId)
	// string "OrderId"
	o = append(o, 0xa7, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64)
	o = msgp.AppendString(o, z.OrderId)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettlePAYGTimeSpanKey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ProductId":
			z.ProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "OrderId":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettlePAYGTimeSpanKey) Msgsize() (s int) {
	s = 1 + 10 + msgp.StringPrefixSize + len(z.ProductId) + 8 + msgp.StringPrefixSize + len(z.OrderId)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettlePaymentType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettlePaymentType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettlePaymentType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettlePaymentType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettlePaymentType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettlePaymentType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettlePaymentType) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleProduct) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			err = dc.ReadExtension(&z.Seller)
			if err != nil {
				err = msgp.WrapError(err, "Seller")
				return
			}
		case "p":
			z.ProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleProduct) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "s"
	err = en.Append(0x82, 0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.Seller)
	if err != nil {
		err = msgp.WrapError(err, "Seller")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductId)
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleProduct) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "s"
	o = append(o, 0x82, 0xa1, 0x73)
	o, err = msgp.AppendExtension(o, &z.Seller)
	if err != nil {
		err = msgp.WrapError(err, "Seller")
		return
	}
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendString(o, z.ProductId)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleProduct) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "s":
			bts, err = msgp.ReadExtensionBytes(bts, &z.Seller)
			if err != nil {
				err = msgp.WrapError(err, "Seller")
				return
			}
		case "p":
			z.ProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleProduct) Msgsize() (s int) {
	s = 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Len() + 2 + msgp.StringPrefixSize + len(z.ProductId)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleProductInvoice) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "TotalAmount":
			z.TotalAmount, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "TotalAmount")
				return
			}
		case "Currency":
			z.Currency, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "StartTime":
			z.StartTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "EndTime":
			z.EndTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		case "Buyer":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "Seller":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "Connection":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Connection")
					return
				}
				z.Connection = nil
			} else {
				if z.Connection == nil {
					z.Connection = new(DoDSettleInvoiceConnDetail)
				}
				err = z.Connection.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Connection")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleProductInvoice) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "TotalAmount"
	err = en.Append(0x87, 0xab, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.TotalAmount)
	if err != nil {
		err = msgp.WrapError(err, "TotalAmount")
		return
	}
	// write "Currency"
	err = en.Append(0xa8, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.Currency)
	if err != nil {
		err = msgp.WrapError(err, "Currency")
		return
	}
	// write "StartTime"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "EndTime"
	err = en.Append(0xa7, 0x45, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndTime)
	if err != nil {
		err = msgp.WrapError(err, "EndTime")
		return
	}
	// write "Buyer"
	err = en.Append(0xa5, 0x42, 0x75, 0x79, 0x65, 0x72)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "Seller"
	err = en.Append(0xa6, 0x53, 0x65, 0x6c, 0x6c, 0x65, 0x72)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "Connection"
	err = en.Append(0xaa, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	if z.Connection == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Connection.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Connection")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleProductInvoice) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "TotalAmount"
	o = append(o, 0x87, 0xab, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendFloat64(o, z.TotalAmount)
	// string "Currency"
	o = append(o, 0xa8, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79)
	o = msgp.AppendString(o, z.Currency)
	// string "StartTime"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.StartTime)
	// string "EndTime"
	o = append(o, 0xa7, 0x45, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.EndTime)
	// string "Buyer"
	o = append(o, 0xa5, 0x42, 0x75, 0x79, 0x65, 0x72)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "Seller"
	o = append(o, 0xa6, 0x53, 0x65, 0x6c, 0x6c, 0x65, 0x72)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "Connection"
	o = append(o, 0xaa, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if z.Connection == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Connection.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Connection")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleProductInvoice) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "TotalAmount":
			z.TotalAmount, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalAmount")
				return
			}
		case "Currency":
			z.Currency, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Currency")
				return
			}
		case "StartTime":
			z.StartTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "EndTime":
			z.EndTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		case "Buyer":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "Seller":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "Connection":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Connection = nil
			} else {
				if z.Connection == nil {
					z.Connection = new(DoDSettleInvoiceConnDetail)
				}
				bts, err = z.Connection.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Connection")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleProductInvoice) Msgsize() (s int) {
	s = 1 + 12 + msgp.Float64Size + 9 + msgp.StringPrefixSize + len(z.Currency) + 10 + msgp.Int64Size + 8 + msgp.Int64Size + 6
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 7
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 11
	if z.Connection == nil {
		s += msgp.NilSize
	} else {
		s += z.Connection.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleProductItem) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "p":
			z.ProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "b":
			z.BuyerProductId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BuyerProductId")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleProductItem) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "p"
	err = en.Append(0x82, 0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.ProductId)
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	// write "b"
	err = en.Append(0xa1, 0x62)
	if err != nil {
		return
	}
	err = en.WriteString(z.BuyerProductId)
	if err != nil {
		err = msgp.WrapError(err, "BuyerProductId")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleProductItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "p"
	o = append(o, 0x82, 0xa1, 0x70)
	o = msgp.AppendString(o, z.ProductId)
	// string "b"
	o = append(o, 0xa1, 0x62)
	o = msgp.AppendString(o, z.BuyerProductId)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleProductItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "p":
			z.ProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
		case "b":
			z.BuyerProductId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BuyerProductId")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleProductItem) Msgsize() (s int) {
	s = 1 + 2 + msgp.StringPrefixSize + len(z.ProductId) + 2 + msgp.StringPrefixSize + len(z.BuyerProductId)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleResourceReadyParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			err = dc.ReadExtension(&z.InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		case "p":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
			if cap(z.ProductId) >= int(zb0002) {
				z.ProductId = (z.ProductId)[:zb0002]
			} else {
				z.ProductId = make([]string, zb0002)
			}
			for za0001 := range z.ProductId {
				z.ProductId[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ProductId", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleResourceReadyParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "i"
	err = en.Append(0x82, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.InternalId)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ProductId)))
	if err != nil {
		err = msgp.WrapError(err, "ProductId")
		return
	}
	for za0001 := range z.ProductId {
		err = en.WriteString(z.ProductId[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ProductId", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleResourceReadyParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "i"
	o = append(o, 0x82, 0xa1, 0x69)
	o, err = msgp.AppendExtension(o, &z.InternalId)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ProductId)))
	for za0001 := range z.ProductId {
		o = msgp.AppendString(o, z.ProductId[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleResourceReadyParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			bts, err = msgp.ReadExtensionBytes(bts, &z.InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		case "p":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductId")
				return
			}
			if cap(z.ProductId) >= int(zb0002) {
				z.ProductId = (z.ProductId)[:zb0002]
			} else {
				z.ProductId = make([]string, zb0002)
			}
			for za0001 := range z.ProductId {
				z.ProductId[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProductId", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleResourceReadyParam) Msgsize() (s int) {
	s = 1 + 2 + msgp.ExtensionPrefixSize + z.InternalId.Len() + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.ProductId {
		s += msgp.StringPrefixSize + len(z.ProductId[za0001])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleResponseAction) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleResponseAction(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleResponseAction) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleResponseAction) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleResponseAction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleResponseAction(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleResponseAction) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleResponseParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Action")
					return
				}
				z.Action = DoDSettleResponseAction(zb0002)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleResponseParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "c"
	err = en.Append(0x81, 0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.Action))
	if err != nil {
		err = msgp.WrapError(err, "Action")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleResponseParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "c"
	o = append(o, 0x81, 0xa1, 0x63)
	o = msgp.AppendInt(o, int(z.Action))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleResponseParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "c":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Action")
					return
				}
				z.Action = DoDSettleResponseAction(zb0002)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleResponseParam) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleServiceClass) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleServiceClass(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleServiceClass) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleServiceClass) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleServiceClass) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = DoDSettleServiceClass(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleServiceClass) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleTerminateOrderParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						err = dc.ReadExtension(&z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "c":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0004) {
				z.Connections = (z.Connections)[:zb0004]
			} else {
				z.Connections = make([]*DoDSettleChangeConnectionParam, zb0004)
			}
			for za0001 := range z.Connections {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleChangeConnectionParam)
					}
					var zb0005 uint32
					zb0005, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "p":
							z.Connections[za0001].ProductId, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "ProductId")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							err = z.Connections[za0001].DoDSettleConnectionDynamicParam.DecodeMsg(dc)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleTerminateOrderParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "b"
	err = en.Append(0x83, 0xa1, 0x62)
	if err != nil {
		return
	}
	if z.Buyer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Buyer.Name)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Name")
			return
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	if z.Seller == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// map header, size 2
		// write "a"
		err = en.Append(0x82, 0xa1, 0x61)
		if err != nil {
			return
		}
		err = en.WriteExtension(&z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Seller.Name)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Name")
			return
		}
	}
	// write "c"
	err = en.Append(0xa1, 0x63)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Connections)))
	if err != nil {
		err = msgp.WrapError(err, "Connections")
		return
	}
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "p"
			err = en.Append(0x82, 0xa1, 0x70)
			if err != nil {
				return
			}
			err = en.WriteString(z.Connections[za0001].ProductId)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "ProductId")
				return
			}
			// write "DoDSettleConnectionDynamicParam"
			err = en.Append(0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			if err != nil {
				return
			}
			err = z.Connections[za0001].DoDSettleConnectionDynamicParam.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleTerminateOrderParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "b"
	o = append(o, 0x83, 0xa1, 0x62)
	if z.Buyer == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Buyer.Address)
		if err != nil {
			err = msgp.WrapError(err, "Buyer", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Buyer.Name)
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	if z.Seller == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "a"
		o = append(o, 0x82, 0xa1, 0x61)
		o, err = msgp.AppendExtension(o, &z.Seller.Address)
		if err != nil {
			err = msgp.WrapError(err, "Seller", "Address")
			return
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendString(o, z.Seller.Name)
	}
	// string "c"
	o = append(o, 0xa1, 0x63)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Connections)))
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "p"
			o = append(o, 0x82, 0xa1, 0x70)
			o = msgp.AppendString(o, z.Connections[za0001].ProductId)
			// string "DoDSettleConnectionDynamicParam"
			o = append(o, 0xbf, 0x44, 0x6f, 0x44, 0x53, 0x65, 0x74, 0x74, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x50, 0x61, 0x72, 0x61, 0x6d)
			o, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleTerminateOrderParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "b":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Buyer = nil
			} else {
				if z.Buyer == nil {
					z.Buyer = new(DoDSettleUser)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buyer")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buyer")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Buyer.Address)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Address")
							return
						}
					case "n":
						z.Buyer.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Buyer")
							return
						}
					}
				}
			}
		case "s":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Seller = nil
			} else {
				if z.Seller == nil {
					z.Seller = new(DoDSettleUser)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Seller")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seller")
						return
					}
					switch msgp.UnsafeString(field) {
					case "a":
						bts, err = msgp.ReadExtensionBytes(bts, &z.Seller.Address)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Address")
							return
						}
					case "n":
						z.Seller.Name, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller", "Name")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seller")
							return
						}
					}
				}
			}
		case "c":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connections")
				return
			}
			if cap(z.Connections) >= int(zb0004) {
				z.Connections = (z.Connections)[:zb0004]
			} else {
				z.Connections = make([]*DoDSettleChangeConnectionParam, zb0004)
			}
			for za0001 := range z.Connections {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Connections[za0001] = nil
				} else {
					if z.Connections[za0001] == nil {
						z.Connections[za0001] = new(DoDSettleChangeConnectionParam)
					}
					var zb0005 uint32
					zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Connections", za0001)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Connections", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "p":
							z.Connections[za0001].ProductId, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "ProductId")
								return
							}
						case "DoDSettleConnectionDynamicParam":
							bts, err = z.Connections[za0001].DoDSettleConnectionDynamicParam.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001, "DoDSettleConnectionDynamicParam")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Connections", za0001)
								return
							}
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleTerminateOrderParam) Msgsize() (s int) {
	s = 1 + 2
	if z.Buyer == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Buyer.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Buyer.Name)
	}
	s += 2
	if z.Seller == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 2 + msgp.ExtensionPrefixSize + z.Seller.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Seller.Name)
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0001 := range z.Connections {
		if z.Connections[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 2 + msgp.StringPrefixSize + len(z.Connections[za0001].ProductId) + 32 + z.Connections[za0001].DoDSettleConnectionDynamicParam.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleUpdateOrderInfoParam) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			err = dc.ReadExtension(&z.InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		case "oi":
			z.OrderId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "pis":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProductIds")
				return
			}
			if cap(z.ProductIds) >= int(zb0002) {
				z.ProductIds = (z.ProductIds)[:zb0002]
			} else {
				z.ProductIds = make([]*DoDSettleProductItem, zb0002)
			}
			for za0001 := range z.ProductIds {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "ProductIds", za0001)
						return
					}
					z.ProductIds[za0001] = nil
				} else {
					if z.ProductIds[za0001] == nil {
						z.ProductIds[za0001] = new(DoDSettleProductItem)
					}
					var zb0003 uint32
					zb0003, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "ProductIds", za0001)
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "ProductIds", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "p":
							z.ProductIds[za0001].ProductId, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0001, "ProductId")
								return
							}
						case "b":
							z.ProductIds[za0001].BuyerProductId, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0001, "BuyerProductId")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0001)
								return
							}
						}
					}
				}
			}
		case "s":
			{
				var zb0004 int
				zb0004, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				z.Status = DoDSettleOrderState(zb0004)
			}
		case "fr":
			z.FailReason, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FailReason")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleUpdateOrderInfoParam) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "i"
	err = en.Append(0x85, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.InternalId)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	// write "oi"
	err = en.Append(0xa2, 0x6f, 0x69)
	if err != nil {
		return
	}
	err = en.WriteString(z.OrderId)
	if err != nil {
		err = msgp.WrapError(err, "OrderId")
		return
	}
	// write "pis"
	err = en.Append(0xa3, 0x70, 0x69, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ProductIds)))
	if err != nil {
		err = msgp.WrapError(err, "ProductIds")
		return
	}
	for za0001 := range z.ProductIds {
		if z.ProductIds[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "p"
			err = en.Append(0x82, 0xa1, 0x70)
			if err != nil {
				return
			}
			err = en.WriteString(z.ProductIds[za0001].ProductId)
			if err != nil {
				err = msgp.WrapError(err, "ProductIds", za0001, "ProductId")
				return
			}
			// write "b"
			err = en.Append(0xa1, 0x62)
			if err != nil {
				return
			}
			err = en.WriteString(z.ProductIds[za0001].BuyerProductId)
			if err != nil {
				err = msgp.WrapError(err, "ProductIds", za0001, "BuyerProductId")
				return
			}
		}
	}
	// write "s"
	err = en.Append(0xa1, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.Status))
	if err != nil {
		err = msgp.WrapError(err, "Status")
		return
	}
	// write "fr"
	err = en.Append(0xa2, 0x66, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.FailReason)
	if err != nil {
		err = msgp.WrapError(err, "FailReason")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleUpdateOrderInfoParam) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "i"
	o = append(o, 0x85, 0xa1, 0x69)
	o, err = msgp.AppendExtension(o, &z.InternalId)
	if err != nil {
		err = msgp.WrapError(err, "InternalId")
		return
	}
	// string "oi"
	o = append(o, 0xa2, 0x6f, 0x69)
	o = msgp.AppendString(o, z.OrderId)
	// string "pis"
	o = append(o, 0xa3, 0x70, 0x69, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ProductIds)))
	for za0001 := range z.ProductIds {
		if z.ProductIds[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "p"
			o = append(o, 0x82, 0xa1, 0x70)
			o = msgp.AppendString(o, z.ProductIds[za0001].ProductId)
			// string "b"
			o = append(o, 0xa1, 0x62)
			o = msgp.AppendString(o, z.ProductIds[za0001].BuyerProductId)
		}
	}
	// string "s"
	o = append(o, 0xa1, 0x73)
	o = msgp.AppendInt(o, int(z.Status))
	// string "fr"
	o = append(o, 0xa2, 0x66, 0x72)
	o = msgp.AppendString(o, z.FailReason)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleUpdateOrderInfoParam) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			bts, err = msgp.ReadExtensionBytes(bts, &z.InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalId")
				return
			}
		case "oi":
			z.OrderId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderId")
				return
			}
		case "pis":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductIds")
				return
			}
			if cap(z.ProductIds) >= int(zb0002) {
				z.ProductIds = (z.ProductIds)[:zb0002]
			} else {
				z.ProductIds = make([]*DoDSettleProductItem, zb0002)
			}
			for za0001 := range z.ProductIds {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.ProductIds[za0001] = nil
				} else {
					if z.ProductIds[za0001] == nil {
						z.ProductIds[za0001] = new(DoDSettleProductItem)
					}
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ProductIds", za0001)
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "ProductIds", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "p":
							z.ProductIds[za0001].ProductId, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0001, "ProductId")
								return
							}
						case "b":
							z.ProductIds[za0001].BuyerProductId, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0001, "BuyerProductId")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0001)
								return
							}
						}
					}
				}
			}
		case "s":
			{
				var zb0004 int
				zb0004, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				z.Status = DoDSettleOrderState(zb0004)
			}
		case "fr":
			z.FailReason, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailReason")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleUpdateOrderInfoParam) Msgsize() (s int) {
	s = 1 + 2 + msgp.ExtensionPrefixSize + z.InternalId.Len() + 3 + msgp.StringPrefixSize + len(z.OrderId) + 4 + msgp.ArrayHeaderSize
	for za0001 := range z.ProductIds {
		if z.ProductIds[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 2 + msgp.StringPrefixSize + len(z.ProductIds[za0001].ProductId) + 2 + msgp.StringPrefixSize + len(z.ProductIds[za0001].BuyerProductId)
		}
	}
	s += 2 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.FailReason)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleUser) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "a":
			err = dc.ReadExtension(&z.Address)
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		case "n":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DoDSettleUser) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "a"
	err = en.Append(0x82, 0xa1, 0x61)
	if err != nil {
		return
	}
	err = en.WriteExtension(&z.Address)
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	// write "n"
	err = en.Append(0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DoDSettleUser) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "a"
	o = append(o, 0x82, 0xa1, 0x61)
	o, err = msgp.AppendExtension(o, &z.Address)
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	// string "n"
	o = append(o, 0xa1, 0x6e)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleUser) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "a":
			bts, err = msgp.ReadExtensionBytes(bts, &z.Address)
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		case "n":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DoDSettleUser) Msgsize() (s int) {
	s = 1 + 2 + msgp.ExtensionPrefixSize + z.Address.Len() + 2 + msgp.StringPrefixSize + len(z.Name)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DoDSettleUserInfos) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "InternalIds")
				return
			}
			if cap(z.InternalIds) >= int(zb0002) {
				z.InternalIds = (z.InternalIds)[:zb0002]
			} else {
				z.InternalIds = make([]*DoDSettleInternalIdWrap, zb0002)
			}
			for za0001 := range z.InternalIds {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "InternalIds", za0001)
						return
					}
					z.InternalIds[za0001] = nil
				} else {
					if z.InternalIds[za0001] == nil {
						z.InternalIds[za0001] = new(DoDSettleInternalIdWrap)
					}
					var zb0003 uint32
					zb0003, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "InternalIds", za0001)
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "InternalIds", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "i":
							err = dc.ReadExtension(&z.InternalIds[za0001].InternalId)
							if err != nil {
								err = msgp.WrapError(err, "InternalIds", za0001, "InternalId")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "InternalIds", za0001)
								return
							}
						}
					}
				}
			}
		case "p":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProductIds")
				return
			}
			if cap(z.ProductIds) >= int(zb0004) {
				z.ProductIds = (z.ProductIds)[:zb0004]
			} else {
				z.ProductIds = make([]*DoDSettleProduct, zb0004)
			}
			for za0002 := range z.ProductIds {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "ProductIds", za0002)
						return
					}
					z.ProductIds[za0002] = nil
				} else {
					if z.ProductIds[za0002] == nil {
						z.ProductIds[za0002] = new(DoDSettleProduct)
					}
					var zb0005 uint32
					zb0005, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "ProductIds", za0002)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "ProductIds", za0002)
							return
						}
						switch msgp.UnsafeString(field) {
						case "s":
							err = dc.ReadExtension(&z.ProductIds[za0002].Seller)
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0002, "Seller")
								return
							}
						case "p":
							z.ProductIds[za0002].ProductId, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0002, "ProductId")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0002)
								return
							}
						}
					}
				}
			}
		case "o":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OrderIds")
				return
			}
			if cap(z.OrderIds) >= int(zb0006) {
				z.OrderIds = (z.OrderIds)[:zb0006]
			} else {
				z.OrderIds = make([]*DoDSettleOrder, zb0006)
			}
			for za0003 := range z.OrderIds {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "OrderIds", za0003)
						return
					}
					z.OrderIds[za0003] = nil
				} else {
					if z.OrderIds[za0003] == nil {
						z.OrderIds[za0003] = new(DoDSettleOrder)
					}
					var zb0007 uint32
					zb0007, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "OrderIds", za0003)
						return
					}
					for zb0007 > 0 {
						zb0007--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "OrderIds", za0003)
							return
						}
						switch msgp.UnsafeString(field) {
						case "s":
							err = dc.ReadExtension(&z.OrderIds[za0003].Seller)
							if err != nil {
								err = msgp.WrapError(err, "OrderIds", za0003, "Seller")
								return
							}
						case "o":
							z.OrderIds[za0003].OrderId, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "OrderIds", za0003, "OrderId")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "OrderIds", za0003)
								return
							}
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DoDSettleUserInfos) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "i"
	err = en.Append(0x83, 0xa1, 0x69)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.InternalIds)))
	if err != nil {
		err = msgp.WrapError(err, "InternalIds")
		return
	}
	for za0001 := range z.InternalIds {
		if z.InternalIds[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 1
			// write "i"
			err = en.Append(0x81, 0xa1, 0x69)
			if err != nil {
				return
			}
			err = en.WriteExtension(&z.InternalIds[za0001].InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalIds", za0001, "InternalId")
				return
			}
		}
	}
	// write "p"
	err = en.Append(0xa1, 0x70)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ProductIds)))
	if err != nil {
		err = msgp.WrapError(err, "ProductIds")
		return
	}
	for za0002 := range z.ProductIds {
		if z.ProductIds[za0002] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "s"
			err = en.Append(0x82, 0xa1, 0x73)
			if err != nil {
				return
			}
			err = en.WriteExtension(&z.ProductIds[za0002].Seller)
			if err != nil {
				err = msgp.WrapError(err, "ProductIds", za0002, "Seller")
				return
			}
			// write "p"
			err = en.Append(0xa1, 0x70)
			if err != nil {
				return
			}
			err = en.WriteString(z.ProductIds[za0002].ProductId)
			if err != nil {
				err = msgp.WrapError(err, "ProductIds", za0002, "ProductId")
				return
			}
		}
	}
	// write "o"
	err = en.Append(0xa1, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.OrderIds)))
	if err != nil {
		err = msgp.WrapError(err, "OrderIds")
		return
	}
	for za0003 := range z.OrderIds {
		if z.OrderIds[za0003] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "s"
			err = en.Append(0x82, 0xa1, 0x73)
			if err != nil {
				return
			}
			err = en.WriteExtension(&z.OrderIds[za0003].Seller)
			if err != nil {
				err = msgp.WrapError(err, "OrderIds", za0003, "Seller")
				return
			}
			// write "o"
			err = en.Append(0xa1, 0x6f)
			if err != nil {
				return
			}
			err = en.WriteString(z.OrderIds[za0003].OrderId)
			if err != nil {
				err = msgp.WrapError(err, "OrderIds", za0003, "OrderId")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DoDSettleUserInfos) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "i"
	o = append(o, 0x83, 0xa1, 0x69)
	o = msgp.AppendArrayHeader(o, uint32(len(z.InternalIds)))
	for za0001 := range z.InternalIds {
		if z.InternalIds[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 1
			// string "i"
			o = append(o, 0x81, 0xa1, 0x69)
			o, err = msgp.AppendExtension(o, &z.InternalIds[za0001].InternalId)
			if err != nil {
				err = msgp.WrapError(err, "InternalIds", za0001, "InternalId")
				return
			}
		}
	}
	// string "p"
	o = append(o, 0xa1, 0x70)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ProductIds)))
	for za0002 := range z.ProductIds {
		if z.ProductIds[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "s"
			o = append(o, 0x82, 0xa1, 0x73)
			o, err = msgp.AppendExtension(o, &z.ProductIds[za0002].Seller)
			if err != nil {
				err = msgp.WrapError(err, "ProductIds", za0002, "Seller")
				return
			}
			// string "p"
			o = append(o, 0xa1, 0x70)
			o = msgp.AppendString(o, z.ProductIds[za0002].ProductId)
		}
	}
	// string "o"
	o = append(o, 0xa1, 0x6f)
	o = msgp.AppendArrayHeader(o, uint32(len(z.OrderIds)))
	for za0003 := range z.OrderIds {
		if z.OrderIds[za0003] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "s"
			o = append(o, 0x82, 0xa1, 0x73)
			o, err = msgp.AppendExtension(o, &z.OrderIds[za0003].Seller)
			if err != nil {
				err = msgp.WrapError(err, "OrderIds", za0003, "Seller")
				return
			}
			// string "o"
			o = append(o, 0xa1, 0x6f)
			o = msgp.AppendString(o, z.OrderIds[za0003].OrderId)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DoDSettleUserInfos) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "i":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InternalIds")
				return
			}
			if cap(z.InternalIds) >= int(zb0002) {
				z.InternalIds = (z.InternalIds)[:zb0002]
			} else {
				z.InternalIds = make([]*DoDSettleInternalIdWrap, zb0002)
			}
			for za0001 := range z.InternalIds {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.InternalIds[za0001] = nil
				} else {
					if z.InternalIds[za0001] == nil {
						z.InternalIds[za0001] = new(DoDSettleInternalIdWrap)
					}
					var zb0003 uint32
					zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "InternalIds", za0001)
						return
					}
					for zb0003 > 0 {
						zb0003--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "InternalIds", za0001)
							return
						}
						switch msgp.UnsafeString(field) {
						case "i":
							bts, err = msgp.ReadExtensionBytes(bts, &z.InternalIds[za0001].InternalId)
							if err != nil {
								err = msgp.WrapError(err, "InternalIds", za0001, "InternalId")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "InternalIds", za0001)
								return
							}
						}
					}
				}
			}
		case "p":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProductIds")
				return
			}
			if cap(z.ProductIds) >= int(zb0004) {
				z.ProductIds = (z.ProductIds)[:zb0004]
			} else {
				z.ProductIds = make([]*DoDSettleProduct, zb0004)
			}
			for za0002 := range z.ProductIds {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.ProductIds[za0002] = nil
				} else {
					if z.ProductIds[za0002] == nil {
						z.ProductIds[za0002] = new(DoDSettleProduct)
					}
					var zb0005 uint32
					zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ProductIds", za0002)
						return
					}
					for zb0005 > 0 {
						zb0005--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "ProductIds", za0002)
							return
						}
						switch msgp.UnsafeString(field) {
						case "s":
							bts, err = msgp.ReadExtensionBytes(bts, &z.ProductIds[za0002].Seller)
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0002, "Seller")
								return
							}
						case "p":
							z.ProductIds[za0002].ProductId, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0002, "ProductId")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "ProductIds", za0002)
								return
							}
						}
					}
				}
			}
		case "o":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OrderIds")
				return
			}
			if cap(z.OrderIds) >= int(zb0006) {
				z.OrderIds = (z.OrderIds)[:zb0006]
			} else {
				z.OrderIds = make([]*DoDSettleOrder, zb0006)
			}
			for za0003 := range z.OrderIds {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.OrderIds[za0003] = nil
				} else {
					if z.OrderIds[za0003] == nil {
						z.OrderIds[za0003] = new(DoDSettleOrder)
					}
					var zb0007 uint32
					zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "OrderIds", za0003)
						return
					}
					for zb0007 > 0 {
						zb0007--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "OrderIds", za0003)
							return
						}
						switch msgp.UnsafeString(field) {
						case "s":
							bts, err = msgp.ReadExtensionBytes(bts, &z.OrderIds[za0003].Seller)
							if err != nil {
								err = msgp.WrapError(err, "OrderIds", za0003, "Seller")
								return
							}
						case "o":
							z.OrderIds[za0003].OrderId, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "OrderIds", za0003, "OrderId")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "OrderIds", za0003)
								return
							}
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DoDSettleUserInfos) Msgsize() (s int) {
	s = 1 + 2 + msgp.ArrayHeaderSize
	for za0001 := range z.InternalIds {
		if z.InternalIds[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 2 + msgp.ExtensionPrefixSize + z.InternalIds[za0001].InternalId.Len()
		}
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0002 := range z.ProductIds {
		if z.ProductIds[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 2 + msgp.ExtensionPrefixSize + z.ProductIds[za0002].Seller.Len() + 2 + msgp.StringPrefixSize + len(z.ProductIds[za0002].ProductId)
		}
	}
	s += 2 + msgp.ArrayHeaderSize
	for za0003 := range z.OrderIds {
		if z.OrderIds[za0003] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 2 + msgp.ExtensionPrefixSize + z.OrderIds[za0003].Seller.Len() + 2 + msgp.StringPrefixSize + len(z.OrderIds[za0003].OrderId)
		}
	}
	return
}
